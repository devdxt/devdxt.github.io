<!DOCTYPE html>
<html>
<head>
	<title>Test Armada</title>
	<link rel="stylesheet" type="text/css" href="/css/normalize.css">
	<link rel="stylesheet" type="text/css" href="/css/common.css">
	<link rel="stylesheet" type="text/css" href="/css/header.css">
	<link rel="stylesheet" type="text/css" href="/css/home.css">
	<link rel="stylesheet" type="text/css" href="/css/doc.css">
	<link rel="stylesheet" type="text/css" href="/css/training.css">
	<link rel="stylesheet" type="text/css" href="/css/faq.css">
	<link rel="stylesheet" type="text/css" href="/css/contact.css">
	<link rel="stylesheet" type="text/css" href="/css/search.css">
	<link rel="stylesheet" type="text/css" href="/css/custom.css">
	<link rel="stylesheet" type="text/css" href="/css/slick.css">
	<link rel="stylesheet" type="text/css" href="/css/prism.css">
	<link rel="stylesheet" type="text/css" href="/css/responsive.css">
	
	<link rel="shortcut icon" href="/documentation/images/favicon.ico">
	
</head>
<body>
	
	<header>
		<a href="/">
			<img src="/documentation/images/ta-logo.png" class="logo" alt="Main Brand Logo"
				 srcset="/documentation/images/ta-logo%402x.png 2x, /documentation/images/ta-logo%403x.png 3x">
		</a>
		<form action="/search" method="get">
			<input type="text" id="search-box" name="query" placeholder="Search" class="search-box">
			<div class="select-box">
				<select name="fleet" id="fleet-box" onchange="document.getElementById('search-box').focus();">
					<option value="all">All Fleets</option>
					
					<option value="Functional Testing">Functional Testing</option>
					
					<option value="Mocking">Mocking</option>
					
					<option value="Performance Testing">Performance Testing</option>
					
					<option value="Data Insights">Data Insights</option>
					
				</select>
			</div>
		</form>
		<div class="nav-links">
			
			<div class="nav-links__fleets">
				<a class="nav-links__fleets-btn">
					Fleets <img src="/images/arrow-down-icon.png" class="arrow-down-icon"
								srcset="/images/arrow-down-icon%402x.png 2x,
										/images/arrow-down-icon%403x.png 3x">
				</a>
				<div class="nav-links__fleets-content">
					<a href="/">
						All Fleets
					</a>
					
					<a href="/Functional Testing/">
						Functional Testing
					</a>
					
					<a href="/Mocking/">
						Mocking
					</a>
					
					<a href="/Performance Testing/">
						Performance Testing
					</a>
					
					<a href="/Data Insights/">
						Data Insights
					</a>
					
				</div>
			</div>
			
			
			
			
			<a href="/documentation/About.html" class="nav-links__main-links">About Us</a>
			
			
			
			
			
			
			<a href="/faq" class="nav-links__main-links">FAQ</a>
			
			
			
			<a href="https://github.com/TestArmada/" target="_blank" class="nav-links__main-links">GitHub</a>
			
		</div>
	</header>

	<div class="container">
		<div class="inner-container">

  <div class="breadcrumb">
    <p>
      <a class="breadcrumb__link" href="/">Home</a>
      <img src="/images/arrow-right-icon.png" srcset="/images/arrow-right-icon@2x.png 2x,
              /images/arrow-right-icon@3x.png 3x" class="arrow-right-icon">
      <span class="breadcrumb__current-page">Search Results</span>
    </p>
  </div>

  <div class="search-content">
    <h2 id="result-count">Searching...</h2>
    <p id="not-found-message">This means that we either couldn't find a match for your searched query in our documentation or it's a very common term that returned too many results. Please refine your search query and try again.</p>
    <div id="search-results"></div>
    <div id="pagination" class="pagination"></div>
  </div>

</div>

<script>
  window.store = {
    
      "documentation-ss-20portal-introduction": {
        "title": "SS Portal Introduction",
        "content": "            Home            SS Portal Introduction        IntroductionThe Self-Service Portal (S.S. Portal) is a UI tool enabling developers to setup and execute functional, frontend and backend performance test projects with a few clicks. The tool also provides data insights offering real-time and trending reports giving you the power to troubleshoot and debug issues on demand and monitor the health of your test suite.Check out a short demo video of our tool:S.S. Portal Functional Test Setup WalkthroughS.S. Portal Data Insights WalkthroughS.S. Portal On-boarding InstructionsOn-boarding to the new platform could not be easier.For Existing Customers on Test Armada and Looper: DXT will migrate your project data and created a PR with simple configuration change to your existing Looper yml file. So, to take advantage of the new self-service portal, you simply need to review and merge the PR.Please note: You will continue to have access for existing Admiral portal along with S. S. Portal in parallel.For New Customers or Customer that have an existing Looper Job: Due to popular demand, we are monitoring access to the portal in Q2. If you are interested in taking the UI for a test drive, please contact us atSlack Channel: #testautomationFile a ticket at our service desk and someone will respond to your requestSupportWith any new release, we know there will be a few bumps. However, we are here to support you with any issue or problem you make encounter. Below are a few resources to help with your on-boarding process:Self-Service HelpS.S. Portal Getting Started GuideDocumentation outlining TDK usage, API references, training, and FAQsOn-Call SupportPlease find our on-call support information on the contact page.In addition, we will be hosting office open hours between 11 am-Noon on the following days to help address any questions you have in real-time:Thursday, June 21st, 2018Thursday, June 28th, 2018Thursday, July 5th, 2018Thursday, July 12th, 2018Here is link to Zoom conference call for above office hours meeting series.  ",
        "url": "/documentation/SS%20Portal Introduction"
      },
    
      "documentation-ss-20portal-getting-started": {
        "title": "SS Portal Getting Started",
        "content": "            Home            SS Portal Getting Started        Self Service Portal Getting Started GuideAccessUse of the Self-Service Portal (S.S. Portal) requires logging in with the same credentials you use to log in to JIRA, GEC Github and other internal services. Users must be granted permissions to view the UI, which is handled when a team is onboarded.If you are having issues logging in, please file a ticket on the DXT service desk with your user ID and the repository of your team (e.g. R-Discovery/product).Viewing your projectAfter logging in, a list of projects is presented in the left menu.Clicking on your project name will display a workspace view offering access to your configured test plans:ReportingFrom the workspace view, you can access the reporting view for any test plan by clicking &quot;View Reporting&quot; on the test plan card.This will show a summary view of the test plan:Test Case HealthThis panel shows a breakdown of test case passes and fails for the time period displayed on the panel. This gives you insight in to the overall health of your test suite in recent runs and how the results are trending.Test Run Execution TimeDisplays a comparison of the runs in the time period denoted on the panel, showing how long each run took in the testing phase.Test CasesShows the number of test cases executed across each run in the time period displayed on the panel.All Test RunsA list of test runs in reverse chronological order (latest to oldest) with overall result of the run displayed.You can use the &quot;Filter Test Runs by Date&quot; option to show only test runs on a specified date (click on &quot;Filter Test Runs by Date&quot; to show a date picker):Additionally, typing in the &quot;Search by Test Run Name, Commit ID or PR #&quot; field allows you to easily locate a specific run:Clicking on a run will show the reporting view for that run specifically:Health Across Test CasesShows the breakdown of passing and failing test cases in the run.Test Case PerformanceOn the left, this shows the 5 test cases that took the longest to execute. Hover over the browser icon to the right of the execution time to see which browser the test case ran in.On the right, this shows the 5 test cases that required the most retries to complete. Again, hovering over the browser icon shows the browser that the test case ran in.Test CasesThis panel shows the individual test cases in the run, and a summary of pass/fail per browser.Clicking &quot;All Status&quot; will allow filtering to show Passing, Failing or All test cases.Clicking &quot;All browsers and devices&quot; shows a list of the browsers in the run, which allows filtering to just the results from that browser.The pagination controls at the bottom of the panel provide access to further results:Clicking on an individual test case provides the summary view for that test case:The browser icons on the left can be clicked to show a summary of the result for that browser.Clicking &quot;Results | CI Jobs&quot; will take you to the Looper job for the run, and &quot;Play Recording&quot; will take you to the video recording of the test execution on SauceLabs.SupportThe Self Service UI is supported by the DXT team via the service desk and for questions, please see #testautomation on Slack.  ",
        "url": "/documentation/SS%20Portal Getting Started"
      },
    
      "documentation-presentations": {
        "title": "Presentations",
        "content": "            Home            Presentations        PresentationsGeneralSauce Labs at Walmart Labs with Test ArmadaSelf Service PortalSelf Service Functional DemoSelf Service Project and Test Plan Setup DemoBackend Performance Reports DemoClient Performance Testing Setup and Reports  ",
        "url": "/documentation/Presentations"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('@walmart/shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/shifu/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',    variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/getMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/shifu/api/state/resetRest API  : curl -X POST http://localhost:8000/shifu/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/registerSessionRest API  : curl http://localhost:8000/shifu/api/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/shifu/api/getSessionsRest API  : curl http://localhost:8000/shifu/api/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/checkSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/closeSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/closeSession/{sessionid}",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)If inside of Walmart you need npm access to the internal nexus/npm repo2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;@walmart/shifu&quot;: &quot;^3.0.4&quot;}3. Add .npmrc file to the projectregistry=https://npme.walmart.com/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes). Once you add that, you will be able to see the usage statistics for your project under your project. If you don't have access to this dashboard, please file a ticket.7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});6. Resetting all variantsYou can reset all variants for all routes for a given session id (default session if not session id is passed) using the resetAllVariants API. Please refer to resetAllVariants in the API guide section.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('@walmart/shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/shifu/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',    variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/getMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/shifu/api/state/resetRest API  : curl -X POST http://localhost:8000/shifu/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/registerSessionRest API  : curl http://localhost:8000/shifu/api/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/shifu/api/getSessionsRest API  : curl http://localhost:8000/shifu/api/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/checkSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/closeSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)If inside of Walmart you need npm access to the internal nexus/npm repo2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;@walmart/shifu&quot;: &quot;^3.0.4&quot;}3. Add .npmrc file to the projectregistry=https://npme.walmart.com/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes). Once you add that, you will be able to see the usage statistics for your project under your project. If you don't have access to this dashboard, please file a ticket.7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});6. Resetting all variantsYou can reset all variants for all routes for a given session id (default session if not session id is passed) using the resetAllVariants API. Please refer to resetAllVariants in the API guide section.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('@walmart/shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/shifu/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',    variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/getMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/shifu/api/state/resetRest API  : curl -X POST http://localhost:8000/shifu/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/registerSessionRest API  : curl http://localhost:8000/shifu/api/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/shifu/api/getSessionsRest API  : curl http://localhost:8000/shifu/api/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/checkSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/closeSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)If inside of Walmart you need npm access to the internal nexus/npm repo2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;@walmart/shifu&quot;: &quot;^3.0.4&quot;}3. Add .npmrc file to the projectregistry=https://npme.walmart.com/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes). Once you add that, you will be able to see the usage statistics for your project under your project. If you don't have access to this dashboard, please file a ticket.7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});6. Resetting all variantsYou can reset all variants for all routes for a given session id (default session if not session id is passed) using the resetAllVariants API. Please refer to resetAllVariants in the API guide section.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('@walmart/shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/shifu/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',    variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/getMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/shifu/api/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/shifu/api/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/shifu/api/state/resetRest API  : curl -X POST http://localhost:8000/shifu/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/registerSessionRest API  : curl http://localhost:8000/shifu/api/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/shifu/api/getSessionsRest API  : curl http://localhost:8000/shifu/api/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/checkSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/shifu/api/closeSession/{sessionid}Rest API  : curl http://localhost:8000/shifu/api/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)If inside of Walmart you need npm access to the internal nexus/npm repo2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;@walmart/shifu&quot;: &quot;^3.0.4&quot;}3. Add .npmrc file to the projectregistry=https://npme.walmart.com/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('@walmart/shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes). Once you add that, you will be able to see the usage statistics for your project under your project. If you don't have access to this dashboard, please file a ticket.7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});6. Resetting all variantsYou can reset all variants for all routes for a given session id (default session if not session id is passed) using the resetAllVariants API. Please refer to resetAllVariants in the API guide section.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-remote-browser-testing": {
        "title": "Remote browser testing",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingRemote browser testingDon’t have a desired browser in your local? No worry, you can use the following executors for remote test.magellan-saucelabs-executor: Drive tests on Saucelabsmagellan-testobject-executor: Drive tests on TestObjectmagellan-browserstack-executor: Drive tests on Browserstackmagellan-seleniumgrid-executor:  Drive tests in selenium gridEnable an executorTo do the remote browser test, you need to enable an executor:Install the wanted executor via npm install or add it into your package.json file.E.g. install from npm install:npm install testarmada-magellan-saucelabs-executor --saveAdd following code in your magellan.json{  &quot;executors&quot;: [    &quot;testarmada-magellan-saucelabs-executor&quot;  ],  &quot;strategy_bail&quot;: &quot;testarmada-magellan-early-bail-strategy&quot;}Please note: Some executors need specific configuration to be functional. Please refer to the README.md in executor’s repo for detail configuration.Run tests with multiple executorsMagellan allows to run tests with one or more executors at the same time. This is done by passing a specific command line argument to magellan.For local tests, after enable magellan-local-executor# to run test in Chrome--local_browser chrome# to run test in both Chrome and Firefox--local_browsers chrome, firefoxQuizCan you enable both magellan-local-executor and magellan-saucelabs-executor for your test? and run test in local Chrome and Chrome 60 on Sauce Labs?",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Remote browser testing"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-prerequisites": {
        "title": "Prerequisites",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingPrerequisitesEven though we’ve included everything that is needed in the package.json file, it’s always good to have an idea on which dependency is a must for your desktop browser test.The following dependencies are required in the package.json.{  &quot;dependencies&quot;: {  &quot;nightwatch&quot;: &quot;^0.9.11&quot;,  &quot;selenium-server&quot;: &quot;^3.1.0&quot;  }}magellan-local-browser is also required for your local test.{  &quot;dependencies&quot;: {  &quot;testarmada-magellan-local-executor&quot;: &quot;^2.0.0&quot;  }}Depending on which browser you want to test, you need to include specific browser driver in your package.json. E.g. If you want to run your tests on both Chrome and Firefox:{  &quot;dependencies&quot;: {    &quot;chromedriver&quot;: &quot;^2.27.2&quot;,    &quot;geckodriver&quot;: &quot;^1.4.0&quot;    }}Then, you need to add these drivers in the nightwatch.json file. E.g.    &quot;cli_args&quot;: {      &quot;webdriver.chrome.driver&quot;: &quot;./node_modules/chromedriver/lib/chromedriver/chromedriver&quot;,      &quot;webdriver.gecko.driver&quot;: &quot;./node_modules/geckodriver/bin/geckodriver&quot;    }",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Prerequisites"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-built-in-browser-testing": {
        "title": "Built-in browser testing",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingBuilt-in browser testingThe sample project has some pre-configured browsers that you can use via --local_browser command.For example, the following command triggers your test in the local Firefox.HOST=dev.walmart.com MOCK_PORT=12000 DPRO_LOCATION=./test/automation/conf/data ./node_modules/.bin/magellan --nightwatch_config ./test/automation/conf/nightwatch.json --config ./test/automation/magellan.json --local_browser firefoxFull list of built in browser can be found at test_settings part in test/automation/conf/nightwatch.json fileTo run test with a new browser, you can just create a new entry in test_settings partQuizCan you make the sample test run on your local simulator's safari browser?Hint: here's the sample Capability:    &quot;appiummweb&quot;: {      &quot;desiredCapabilities&quot;: {        &quot;browserName&quot;: &quot;safari&quot;,        &quot;appiumVersion&quot;: &quot;1.7.2&quot;,        &quot;automationName&quot;: &quot;xcuitest&quot;,        &quot;platformName&quot;: &quot;iOS&quot;,        &quot;platformVersion&quot;: &quot;11.2&quot;,        &quot;deviceName&quot;: &quot;iPhone 8&quot;,        &quot;waitForAppScript&quot;: &quot;true&quot;      },      &quot;selenium&quot;: {        &quot;start_process&quot;: false      },      &quot;appium&quot;: {        &quot;start_process&quot;: true      }   },",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Built-in browser testing"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-tests-framework-page-object-properties": {
        "title": "Page Object properties",
        "content": "About the testsPage Object propertiesPage Object propertiesWe have pages, elements, sections and commands properties under ./lib directory. They are the page object properties required by nightwatch.js. For more information on how to define them please refer this.page is the highest level page object property, defined base on one particular page.One page can have multiple sections.It is useful to define sections of a page. Sections do two things:Provide a level of namespacing under the pageProvide element-level nesting so that any element defined within a section is a descendant of its parent section in the DOMelements are the places that your tests will interact with through commands and assertions on each page. This is made simple using the elements property so that all your elements are defined in a single place.You can add commands to your page object using the commands property. This is a useful way to encapsulate logic about the page that would otherwise live in a test, or multiple tests.command will be called in the context of the page or section where it is defined.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Tests Framework/Page Object properties"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-tests-framework-about-the-tests": {
        "title": "About the tests",
        "content": "About the testsPage Object propertiesWe recommend using Page Objects methodologyThe Page Objects methodology is a popular pattern to write end-to-end tests by wrapping the pages or page fragments of a web app into objects. To know more about it, please read this.About the testsFor our sample framework:Create a separate folder tests for tests in your project. Each file inside it will be loaded as a test.All the tests should extend testarmada-nightwatch-extra/lib/base-test-class, which passes certain information, such as selenium session information and test result.You can override before(), beforeEach(), afterEach() and after() method or add your own methods in your base test.A test can have multiple steps if needed, e.g.:const Test = require(&quot;../lib/base-test&quot;);module.exports = new Test({  tags: [&quot;pageobject&quot;, &quot;web&quot;],  &quot;Load demo first page&quot;: function(client) {    const df = client.page[&quot;demo-first&quot;]();    df      .navigate()      .api.resizeWindow(1200, 800);  },  &quot;Verify all cities on first page&quot;: function(client) {    client      .page[&quot;demo-first&quot;]()      .assert.elContainsText(&quot;#tokyo&quot;, &quot;Tokyo&quot;)      .assert.elContainsText(&quot;.city:eq(1) p:eq(1)&quot;, &quot;Europe&quot;);  },  &quot;Jump to demo second page&quot;: function(client) {    client      .page[&quot;demo-first&quot;]()      .jumpToSecondDemo();  }});Each test should have some tags, this will make it easier to group tests when execute.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Tests Framework/About the tests"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-setup-setup-and-run-demo-tests-locally-and-on-saucelabs": {
        "title": "Setup and run demo tests locally and on SauceLabs",
        "content": "PrerequisitesSetup and run demo tests locally and on SauceLabsSetupIn the repo root (where you did the builder-init install), please follow these steps to setup the archetype project:# 1.run archetype project./node_modules/.bin/builder-init @walmart/otto-archetype-desktop# 2.copy package.json from archetype to your repocp ./test/automation/package.json .# 3.install the dependenciesnpm installThere is an alternative project that might be easier to follow (this one has a sample looper job setup):# 1.get the sample projectgit clone git@gecgithub01.walmart.com:dxt/boilerplate-magellan-desktop.git# 2.install the dependenciesnpm installRun demo test locally:npm run testYou should see  the runner magellan open up 2 Chrome windows at once, and the results of the two tests are aggregated in the console.Run demo test on Sauce Labs:npm run test:saucelabsGo to SauceLabs, after log in, you should be able to view your tests running at Dashboard. The tests are using Chrome60 browser on Windows 10.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Setup/Setup and run demo tests locally and on SauceLabs"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-setup-prerequisites": {
        "title": "Prerequisites",
        "content": "PrerequisitesSetup and run demo tests locally and on SauceLabsMost of you must already know some about web automation. In this training series, we will show you how to leverage OTTO tools to make end-to-end tests easy, reliable, and massively parallel distributing tests across available resources both locally and remotely, to achieve Walmart scale.PrerequisitesHostname mapping and open certain portsPlease add the following hostname mapping in the /etc/hosts file127.0.0.1 dev.walmart.comDemo test will use ports range [12000, 12010], please make sure your machine allows those portsInstall Node.js and NPM (npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer)Install nvmWe recommend using nvm to manage your node and npm version. The sample project recommends node@6.11.2 and above,  npm@3.10.10 and above.nvm install 6.11.2nvm use 6.11.2Install builder-initThe sample project relies on FormidableLabs' builder. Please make sure you have builder-init npm installed.npm install builder-initApply SauceLabs credentials (username and api-key)The demo tests can be executed on SauceLabs. To use it, please make sure you have:SauceLabs account. Click here to apply.Have the following credentials set up in ~/.bashrc fileexport SAUCE_CONNECT_VERSION=4.4.11export SAUCE_USERNAME=${YOUR_SAUCE_NAME}export SAUCE_ACCESS_KEY=${YOUR_SAUCE_API_TOKEN}Install Chrome browser, if you don't have it yetTo get the Walmart internal npm packages, you need to follow the steps: https://sde.walmart.com/docs/proximity/npm.html#downloading-packages",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Setup/Prerequisites"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-magellan-magellan-usage": {
        "title": "Magellan usage",
        "content": "Magellan usageConfigure test profilesMagellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.There are two ways to tell magellan how you want to scale your tests:Via Command Line ArgumentsAll command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command:./node_modules/.bin/magellan --helpE.g. Run tests with 30 workers, 5 retry attempts per failed test:./node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5Via magellan.json FileAll command line arguments of magellan can be placed into magellan.json. You can copy the key value pair straightly into it.For example,./node_modules/.bin/magellan --max_workers 30Is equal to this in magellan.json file:{  &quot;max_workers&quot;: 30}Configuration NotesIf a configuration exists in both  magellan.json  and command line arguments, the one in  magellan.json  will take effect.Magellan searches magellan.json in your repo root by default. If you put it in a different folder, make sure to tell where it is by:./node_modules/.bin/magellan --config ${PATH_TO_MAGELLAN.JSON}Quick Reference Guide for Command-Line UseBy default,  magellan will run your test suite the fastest way possible, in parallelYou can also run it serially (one at a time) by using --serial optionYou can view detailed debug info in --serial mode, with --debug optionTo control which tests to run, could use --tag, --tags option#Specify one tag:$ magellan --tag=smoke#Specify multiple tags:$ magellan --tags=smoke,webTo limit the tests by a file path prefix, use the --group optionTo run one specific test, use the --test flag with a path to the test file",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Magellan/Magellan usage"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-magellan-configure-test-profiles": {
        "title": "Configure test profiles",
        "content": "Magellan usageConfigure test profilesConfigure test profilesThere are two ways to configure test profilesVia --profile command line argumentMagellan can retrieve test profile information from an URL (to your hosted test profile).The hosted test profile file needs to follow the format of:{  &quot;profiles&quot;: {    &quot;microsoftedge&quot;: [{      &quot;browser&quot;: &quot;microsoftedge_14_Windows_10_Desktop&quot;,      &quot;resolution&quot;: &quot;1280x1024&quot;,      &quot;executor&quot;: &quot;sauce&quot;    }],    &quot;tier-one-browsers&quot;: [{       &quot;browser&quot;: &quot;microsoftedge_14_Windows_10_Desktop&quot;,       &quot;resolution&quot;: &quot;1280x1024&quot;,       &quot;executor&quot;: &quot;sauce&quot;      },      {       &quot;browser&quot;: &quot;chrome_latest_Windows_10_Desktop&quot;,       &quot;resolution&quot;: &quot;1280x1024&quot;,       &quot;executor&quot;: &quot;sauce&quot;      }    ]  }}Magellan can read and resolve the hosted profile by the following command:./node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via:./node_modules/.bin/magellan --profile http://some.host#microsoftedge,firefox57Or put multiple test profiles into one collection, such as tier-one-browsers in the above sample. To call it:./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json file is using the same test profile format as the hosted test profile file.To use it:./node_modules/.bin/magellan --profile tier-one-browsers",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Magellan/Configure test profiles"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-ios-automation-native-app-locators": {
        "title": "Native app locators",
        "content": "Desired CapabilitiesNative app locatorsNative app locatorsTo find the native app locators, there is a handy tool:Appium DesktopIt's a GUI wrapper around the Appium server, comes with an Inspector, which enables you to check out the hierarchy of your app.E.g How to find the Password locator in Sign in screenSteps:Open Appium Desktop, and start the serverClick Start Inspector Session buttonAdd the Desired Capabilites property one by one. Or Add them from a .json data, e.g.{        &quot;app&quot;: &quot;/Users/abc/app/Walmart.app&quot;,        &quot;appiumVersion&quot;: &quot;1.7.2&quot;,        &quot;automationName&quot;: &quot;XCUITest&quot;,        &quot;platformName&quot;: &quot;iOS&quot;,        &quot;platformVersion&quot;: &quot;11.2&quot;,        &quot;deviceName&quot;: &quot;iPhone 8&quot;,        &quot;waitForAppScript&quot;: &quot;true&quot;,        &quot;locationServicesAuthorized&quot;: &quot;true&quot;,        &quot;locationServicesEnabled&quot;: &quot;true&quot;,        &quot;bundleId&quot;: &quot;com.walmart.beta.electronics&quot;      }Click Start Session to start the inspectorGo to the Sign In screen, and select Password field in the inspector's left preview window.Check the element's attribute. E.g for this case, it has an unique value &quot;Password&quot;, then we can use accessibility id as the locateStrategy and Password, as the selectorIf the element does not have an unique value, you could locate element by relative xpath. e.g. //XCUIElementTypeSecureTextField[@value=&quot;Password&quot;]Please note - should use accessibility id as much as possible.  xpath is slow and unreliable.QuizPlease find the 'Forgot your password?' locator.Can you make the inspector point to the mocked App? Hint: You can refer to processArguments desired capabilities setup in nightwatch.json file, and you need to start a mock server:node ./resources/run-mock-server-console.js",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/iOS Automation/Native app locators"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-ios-automation-desired-capabilities": {
        "title": "Desired Capabilities",
        "content": "Desired CapabilitiesNative app locatorsAfter we understand the tests framework, we can start to take a closer look on how native iOS app automation worksUnderlying we are using Appium to drive native iOS app automationMost concepts are similar for web and app automations, a few things maybe new to people who come from web automation world:Desired CapabilitiesDesired capabilities are a set of keys and values (i.e., a map or hash) sent to the Appium server to tell the server what kind of automation session we're interested in starting up.There are various capabilities which can modify the behavior of the server during automation.For example, we could set the platformName capability to iOS to tell Appium that we want an iOS session, rather than an Android one. See the capabilities doc for the complete list of capabilities available for Appium.For our sample repo, Desired Capabilities are defined either in profiles in magellan.json file or ./conf/nightwatch.json file. You can specify to use which one in your command line.For example, in your command, you can specify it via --profile appium-ios-app, which is defined in magellan.json file.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/iOS Automation/Desired Capabilities"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-trouble-shooting-trouble-shooting-tips": {
        "title": "Trouble shooting tips",
        "content": "Trouble shooting tipsTrouble shooting tipsJava version errorException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: org/openqa/grid/selenium/GridLauncherV3 : Unsupported major.minor version 52.0         at java.lang.ClassLoader.defineClass1(Native Method)         at java.lang.ClassLoader.defineClass(ClassLoader.java:800)...Tips: Please check your java version (java -version), you should use java 1.8. You can download it here.host pointing errorError: getaddrinfo ENOTFOUND travis.dev    at errnoException (dns.js:28:10)    at GetAddrInfoReqWrap.onlookup \\[as oncomplete\\] (dns.js:76:26)...Tips: Please add travis.dev into your hosts file(/etc/hosts)Want to make sure shifu server up and running, check thisSome general trouble shooting tips for Appium iOS app automation:When run simulator test, please sure the accessibility helper is turned off in your Settings appMake sure the app is compiled for the simulator (or real device) as appropriate (e.g. in debug mode for the simulator), or you might get a  posix spawn  error.If this is the first time you've run Appium, make sure to authorize the use of Instruments. See the  UIAutomation Driver  doc.Tests on iOS may exhibit symptoms similar to a memory leak including sluggish performance or hangs. If you experience this problem, it's likely due to a known issue with NSLog. One option is to remove NSLog from your code.Sometimes iOS UI elements become invalidated milliseconds after they are found. This results in an error that looks like (null) cannot be tapped. Sometimes the only solution is to put the finding-and-clicking code in a retry block.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Trouble Shooting/Trouble shooting tips"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-tests-framework-understand-the-tests-framework": {
        "title": "Understand the tests framework",
        "content": "Execution commandsUnderstand the tests frameworkTests framework structureRecommend practice is Page Objects Model Design Pattern.In our sample boilerplate:Command parameter --test tests/app.test.js executes tests in app.test.js file.Tests are defined in .js files under .tests/ folder, each file is a test.Locators and function commands are grouped by page/screen, and are put in ./lib/pages/device/ folder.E.g in app.test, the login step would require elements and commands that are defined in ./lib/pages/ios/login.js file.Profiles that are used to execute tests in remote, e.g. SauceLabs, are defined in magellan.json fine.Local browsers are defined in nightwatch.json file, they are used for local simulator tests, and they are not supported in profiles.Where to find mobile commandsWhen look at commands in page files, e.g. setMobileElValue() may look new to you. Those mobile commands are defined in ./node_modules/testarmada-nightwatch-extra/lib/commands/mobile.Assertions, e.g. mobileElAttrContains(), are defined in ./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile.To use those mobile commands and assertions, need to add the following lines in nightwatch.json file:  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;  ],  &quot;custom_assertions_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile&quot;  ],You can also add your customized commands into folder ./lib/custom_commands, to increase code reusability. And please remember to add the path to nightwatch.json file, e.g.  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;,    &quot;./lib/custom_commands&quot;  ],QuizRun mocked iOS app sample test in the local box with a different iOS simulator.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Tests Framework/Understand the tests framework"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-tests-framework-execution-commands": {
        "title": "Execution commands",
        "content": "Execution commandsUnderstand the tests frameworkExecution commandsAfter getting your tests up and running, you probably have tons of questions regarding how this work, let’s start with the command that we are using to get the tests running in local box, which is:$ npm run test:iosTo understand what is npm run, please check here.test:ios is a 'script' defined in package.json file, which is:&quot;test:ios&quot;: &quot;DPRO=ios ./node_modules/.bin/magellan --config magellan.json --local_browser appiumiosapp  --test tests/app.test.js --serial --max_test_attempts=1&quot;Commands parameters --test , --serial, --max_test_attempts, etc are all magellan arguments. To find all magellan command line arguments and the usages:./node_modules/.bin/magellan --helpMagellan is part of the functional JS TDK, and it is designed for running tests in massive scale.Following is an example that telling magellan to run tests with 30 workers, 5 retry attempts per failed test./node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5DPRO=ios is telling tests to load data from ./conf/data/ios.jsDPRO  - data provider, support both .json and .js file. We recommend .js format.Each .js data file should return a json object. Please check here, for more details # Example: # To load from ${REPO_ROOT}/config/data/local.js DPRO=local ./node_modules/.bin/magellan --test xxxxx ......--local_browser appiumiosapp tells tests to use testarmada-magellan-local-executor . It loads Desired Capabilities from nightwatch.json.Executor  - acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Tests Framework/Execution commands"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-setup-setup-ios-app-test-on-local-machine": {
        "title": "Setup iOS app test on local machine",
        "content": "Setup iOS app test on local machineSetup iOS app test on Sauce LabsNew to native iOS app testing? No worry, you don’t need to know much to set it up. Let's get your first native iOS app test up and running in a couple of minutes.Setup iOS app test on local machinePrerequisites:Install Xcode 9.2Install Node.js and NPM (npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer)Check that you have at least npm version 3 or above (required by appium@1.7.x):$ npm --version# If not, install npm3$ npm install -g npm@3To get the Walmart internal npm packages, you need to follow the steps: https://sde.walmart.com/docs/proximity/npm.html#downloading-packagesPlease map dev.walmart.com to 127.0.0.1 in your host fileSetup Steps:Get the sample code and install the node package dependencies:# Create a workspace and get the smaple code$ git clone git@gecgithub01.walmart.com:dxt/boilerplate-nightwatch-mobile.git$ cd boilerplate-nightwatch-mobile $ npm install$ npm install appium@1.7.2$ npm install wdVerify all the required items are setup properly by running appium-doctor:# install appium-doctor (may require sudo)$ npm install appium-doctor -g# check that all iOS dependencies are set up correctly$ appium-doctor --iosDownload Walmart app and renamed to Walmart.zip. Unzip it under ./app directory, delete Users folder. Compress ./app/Walmart to ./app/Walmart.zip, replace the the original oneOr get the Walmart.app by using the following command option:curl -L 'http://gec-maven-nexus.walmart.com/nexus/service/local/artifact/maven/redirect?r=pangaea_snapshots&amp;g=com.walmart.ios.development-qa-nightly&amp;a=Walmart.app&amp;v=LATEST&amp;p=zip' &gt; app/Walmart.zip &amp;&amp; unzip -o app/Walmart.zip -d app/ &amp;&amp; rm -rf app/Users app/Walmart.zip &amp;&amp; zip -r app/Walmart.zip app/Walmart.appPlease make sure you have iPhone 8, iOS 11.2 simulator before execute the sample test.If you would like to try out some different simulators, please modify the appiumiosapp part in .conf/nightwatch.json file.Try the sample test:$ npm run test:iosIf you don't have SauceLabs credential , please remove this line in ./magellan.json file:&quot;testarmada-magellan-saucelabs-executor&quot;",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Setup/Setup iOS app test on local machine"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-setup-setup-ios-app-test-on-sauce-labs": {
        "title": "Setup iOS app test on Sauce Labs",
        "content": "Setup iOS app test on local machineSetup iOS app test on Sauce LabsSetup iOS app sample test on Sauce LabsApply Sauce Labs access: hereOpen terminal: (or add them into .bash_profile)$ export SAUCE_USERNAME=${USERNAME}$ export SAUCE_ACCESS_KEY=${ACCESSKEY}Upload the testing iOS app to Sauce Labs# Download Walmart app$ curl -L 'http://gec-maven-nexus.walmart.com/nexus/service/local/artifact/maven/redirect?r=pangaea_snapshots&amp;g=com.walmart.ios.development-qa-nightly&amp;a=Walmart.app&amp;v=LATEST&amp;p=zip' &gt; app/Walmart.zip &amp;&amp; unzip -o app/Walmart.zip -d app/ &amp;&amp; rm -rf app/Users app/Walmart.zip &amp;&amp; zip -r app/Walmart.zip app/Walmart.app# Upload Walmart app to SauceLabs, and name it: Walmart_app.zip$ curl -u ${SAUCE_USERNAME}:${SAUCE_ACCESS_KEY} -X POST &quot;http://saucelabs.com/rest/v1/storage/${SAUCE_USERNAME}/Walmart_app.zip?overwrite=true&quot; -H &quot;Content-Type: application/octet-stream&quot; --data-binary @./app/Walmart.zipTo run tests with live services, use command:DPRO=ios ./node_modules/.bin/magellan --config magellan.json --profile appium-ios-app  --test tests/app.test.js --serial -- max_test_attempts=1To run tests with mocked services, use command:DPRO=ios ./node_modules/.bin/magellan --config magellan.json --profile appium-ios-app-mock-sauce  --test tests/app-mock.test.js --serial --max_test_attempts=1 --sauce_create_tunnelsYou can view your tests running at: https://saucelabs.com/beta/dashboard/tests",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Setup/Setup iOS app test on Sauce Labs"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-tests-framework-tests-framework-structure": {
        "title": "Tests framework structure",
        "content": "Execution commandsTests framework structureTests framework structureRecommend practice is Page Objects Model Design Pattern.In our sample boilerplate:Command parameter --test tests/app-android.test.js executes test in app-android.test.js file.Tests are defined in .js files under .tests/ folder, each file is a test.Locators and function commands are grouped by page/screen, and are put in ./lib/pages/device/ folderE.g in app-android.test.js, the signin() step would require elements and commands that are defined in ./lib/pages/android/home.js file.Profiles that are used to execute tests in remote, e.g. SauceLabs, are defined in magellan.json fine.Local browsers are defined in nightwatch.json file, they are used for local emulator tests, and they are not supported in profiles.Where to find mobile commands and assertionsWhen look at commands in page files, e.g. clickMobileEl() may look new to you. Those mobile commands are defined in ./node_modules/testarmada-nightwatch-extra/lib/commands/mobileAssertions, e.g. mobileElAttrContains(), are defined in ./node_modules/testarmada-nightwatch-extra/lib/assertions/mobileTo use those mobile commands and assertions, need to add the following lines in nightwatch.json file:  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;  ],  &quot;custom_assertions_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile&quot;  ],You can also add your customized commands into folder ./lib/custom_commands, to increase code reusability. And please remember to add the path to nightwatch.json file, e.g.  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;,    &quot;./lib/custom_commands&quot;  ],QuizPlease create new signin test, same as the one in app-android.test.js file, and make the test using the mocked Walmart Android app.Hint:use local_browser &quot;appiumandroidappmock&quot;Need to update the assert text msg, e.g. in line 31 in app-android.test.js file",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Tests Framework/Tests framework structure"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-tests-framework-execution-commands": {
        "title": "Execution commands",
        "content": "Execution commandsTests framework structureExecution commandsAfter getting your tests up and running, you probably have tons of questions regarding how this work, let’s start with the command that we are using to get the tests running in local, which is:$ npm run android:app:testTo understand what is npm run, please check here.android:app:test is a 'script' defined in package.json file, which is:DPRO=android ./node_modules/.bin/magellan --config magellan.json --local_browser appiumandroidapp  --test tests/app-android.test.js --serialCommands parameters --test , --serial, --config, etc are all magellan arguments. To find all magellan command line arguments and the usages:./node_modules/.bin/magellan --helpMagellan is part of the functional JS TDK, and it is designed for running tests in massive scale.Following is an example that telling magellan to run tests with 30 workers, 5 retry attempts per failed test./node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5DPRO=android is telling tests to load test data from ./conf/data/android.jsDPRO  - data provider, support both .json and .js file. We recommend .js format.Each .js data file should return a json object. Please check here, for more details # Example: # To load from ${REPO_ROOT}/config/data/local.js DPRO=local ./node_modules/.bin/magellan --test xxxxx ......--local_browser appiumandroidapp tells tests to use testarmada-magellan-local-executor . It loads Desired Capabilities from nightwatch.json.For our sample here, it will load appiumandroidapp desired capability from nightwatch.json file:&quot;appiumandroidapp&quot;: {  &quot;skip_testcases_on_fail&quot;: true,  &quot;desiredCapabilities&quot;: {    &quot;app&quot;: &quot;./app/Walmart.apk&quot;,    &quot;appiumVersion&quot;: &quot;1.7.2&quot;,    &quot;platformName&quot;: &quot;Android&quot;,    &quot;platformVersion&quot;: &quot;7.1.1&quot;,    &quot;deviceName&quot;: &quot;a71_API_25&quot;  },  &quot;selenium&quot;: {    &quot;start_process&quot;: false  },  &quot;appium&quot;: {    &quot;start_process&quot;: true,    &quot;fullReset&quot;: true  }},To know more about Desired Capability, please read the next training section - Android Automation.Executor  - acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).For local emulator test, you need to enable testarmada-magellan-local-executor in the magellan.json file.For remote emulator test, e.g. on SauceLabs, need to enable testarmada-magellan-saucelabs-executor in the magellan.json file.",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Tests Framework/Execution commands"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-setup-setup-android-app-test-on-local-machine": {
        "title": "Setup Android app test on local machine",
        "content": "PrerequisitesSetup Android app test on local machineSetup Android app test on SauceLabsRun Android app test in local emulatorGet the sample code and install the node package dependencies:# Create a workspace and get the smaple code$ git clone git@gecgithub01.walmart.com:dxt/boilerplate-nightwatch-mobile.git$ cd boilerplate-nightwatch-mobile $ npm install$ npm install appium@1.7.2Verify all the required items are setup properly by running appium-doctor (only needed for the first time using):# install appium-doctor (may require sudo)$ npm install appium-doctor -g# check that all Android dependencies are set up correctly$ appium-doctor --androidDownload Walmart.apk file from the download link provided in slack channel #builds-wmandroid-core and move it to ./app directoryLaunch the a71_API_25 AVD in the emulatorTry the sample test:$ npm run android:app:testYou should be able to see the login test running on the Android EmulatorIf you don't have SauceLabs credential , please remove this line in ./magellan.json file:&quot;testarmada-magellan-saucelabs-executor&quot;In the sample, there is another way to automatically download the Walmart Android app, launch emulator and start the sample test:ANDROID_HOME=AAA AVD_NAME=BBB npm run test:androidPlease note: the AVD_NAME may different from the AVD manager you see from Android Studio, you can find the right name from the following command:${ANDROID_HOME}/platform-tools/emulator -list-avdsTo know more about emulator commands, please read this.",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Setup/Setup Android app test on local machine"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-setup-setup-android-app-test-on-saucelabs": {
        "title": "Setup Android app test on SauceLabs",
        "content": "PrerequisitesSetup Android app test on local machineSetup Android app test on SauceLabsRun Android app test on SauceLabsApply Sauce Labs access: hereOpen terminal: (or add them into .bash_profile)$ export SAUCE_USERNAME=${USERNAME}$ export SAUCE_ACCESS_KEY=${ACCESSKEY}Upload ./app/Walmart.apk to SauceLabs via following curl$ curl -u ${SAUCE_USERNAME}:${SAUCE_ACCESS_KEY} -X POST &quot;http://saucelabs.com/rest/v1/storage/${SAUCE_USERNAME}/Walmart_app.apk?overwrite=true&quot; -H &quot;Content-Type: application/octet-stream&quot; --data-binary @./app/Walmart.apkRun the Android sample app test on SauceLabs$ DPRO=android ./node_modules/.bin/magellan --nightwatch_config conf/nightwatch.json --profile appium-android-app --test tests/app-android.test.js --max_test_attempts=1You can view your tests running at: https://saucelabs.com/beta/dashboard/testsQuizPlease create a new AVD, e.g. Nexus S phone, Nougat 25, Android 7.1.1, name it as: Nexus_S_API_25, and run the sample test on this new created emulator.",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Setup/Setup Android app test on SauceLabs"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-setup-prerequisites": {
        "title": "Prerequisites",
        "content": "PrerequisitesSetup Android app test on local machineSetup Android app test on SauceLabsNew to Android app automation testing? No worry, you don’t need to know much to set it up. Let's get your first Android app test up and running in a couple of minutes.Prerequisites:Install latest Android StudioUpdate the following through Tools &gt; SDK Manager:SDK Platforms: Download Android 7.1.1 (Nougat)Expand package details and include Google APIs Intel x86 Atom_64 System ImageSDK Tools: Update Android SDK Build-Tools, Android Emulator, Android SDK Platform-Tools, Android SDK Tools, Intel x86 Emulator AcceleratorCreate this Android Virtual Device (AVD):Download a71_device.xmlGo to Tools &gt; AVD Manager in Android StudioClick on Create Virtual DeviceClick on Import Hardware ProfilesSelect the a71_device.xml fileRefresh page, select a71 device profile, and click NextClick on x86 Images tabSelect Nougat x86_64 Android 7.1.1 (Google APIs) (download may be required), and click NextSet AVD Name as a71_API_25, and click FinishInstall Node.js and NPM (npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer)Check that you have at least npm version 3 or above (required by appium@1.7.x):$ npm --version# If not, install npm3$ npm install -g npm@3To get the Walmart internal npm packages, you need to follow the steps: https://sde.walmart.com/docs/proximity/npm.html#downloading-packages",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Setup/Prerequisites"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-android-automation-native-android-locators": {
        "title": "Native Android locators",
        "content": "Desired CapabilitiesNative Android locatorsNative Android app locatorsTo find native Android app locators, there is a handy tool:Appium DesktopIt's a GUI wrapper around the Appium server, comes with an Inspector, which enables you to check out the hierarchy of your app.E.g How to find the SIGN IN button in the following screenSteps:Open Appium Desktop, and start the serverClick Start Inspector Session buttonAdd the Desired Capabilites property one by one. Or Add them from a .json data, e.g.{  &quot;platformName&quot;: &quot;Android&quot;,  &quot;platformVersion&quot;: &quot;7.1.1&quot;,  &quot;deviceName&quot;: &quot;a71_API_25&quot;,  &quot;app&quot;: &quot;/Users/abc/app/Walmart.apk&quot;,  &quot;locationServicesAuthorized&quot;: true,  &quot;locationServicesEnabled&quot;: true}Click Start Session to start the inspectorGo to the Sign In screen, and select SIGN IN field in the inspector's left preview window.Check the element's attribute. E.g for this case, it has an unique id &quot;com.walmart.android:id/app_nav_header_sign_in&quot;, then we can use ** id** as the locateStrategy and com.walmart.android:id/app_nav_header_sign_in, as the selectorIf the element does not have an unique value, you could locate element by relative xpath. e.g. //android.widget.Button[@value=&quot;Password&quot;]Please note - should use accessibility id or id as much as possible.  xpath is slow and unreliable.QuizPlease automate Verify Empty Cart test, steps:Launch the Walmart Android appClick 'Cart' icon in the top navigation barVerify you will see msg &quot;You have no saved items right now&quot; in Cart page",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Android Automation/Native Android locators"
      },
    
      "documentation-functional-testing-native-android-javascript-training-guide-android-automation-desired-capabilities": {
        "title": "Desired Capabilities",
        "content": "Desired CapabilitiesNative Android locatorsDesired CapabilitiesAfter we understand the tests framework, we can start to take a closer look on how Android app automation worksUnderlying we are using Appium to drive native Android app automationMost concepts are similar for web and app automations, a few things maybe new to people who come from web automation world:Desired CapabilitiesDesired capabilities are a set of keys and values (i.e., a map or hash) sent to the Appium server to tell the server what kind of automation session we're interested in starting up.There are various capabilities which can modify the behavior of the server during automation.For example, we could set the platformName capability to Android to tell Appium that we want an Android session, rather than an iOS one. See the capabilities doc for the complete list of capabilities available for Appium.For our sample repo, Desired Capabilities are defined either in profiles in magellan.json file or in ./conf/nightwatch.json file. You can specify to use which one in your command line.For example, in your command, you can specify it via --profile appium-ios-app, which means look up desired capability defined in profile style in magellan.json file.It is highly recommended to set the  appPackage  and  appActivity  capabilities in order to let Appium know exactly which package and activity should be launched for your application. Otherwise, Appium will try to determine these automatically from your app manifest. E.g.    &quot;appium-android-app&quot;: [      {        &quot;browser&quot;: &quot;Android_GoogleAPI_Emulator_Android_7_1_Android&quot;,        &quot;orientation&quot;: &quot;portrait&quot;,        &quot;appium&quot;: {          &quot;app&quot;: &quot;sauce-storage:Walmart_app.apk&quot;,          &quot;platformName&quot;: &quot;Android&quot;,          &quot;appiumVersion&quot;: &quot;1.7.2&quot;,          &quot;fullReset&quot;: &quot;true&quot;,          &quot;noReset&quot;: &quot;false&quot;,          &quot;appActivity&quot;: &quot;com.walmart.android.app.main.MainActivity&quot;,          &quot;appWaitActivity&quot;: &quot;com.walmart.android.app.main.HomeActivity&quot;        }      }    ],QuizCan you create a Desired Capability to using the mocked Android app?Hint:You should add this parameter in:&quot;optionalIntentArguments&quot;: &quot;-e automation.extra.service.PROFILE 'stage' -e automation.extra.service.CONFIG '[{\\&quot;services\\&quot;:[\\&quot;quimby\\&quot;,\\&quot;receiptsQuery\\&quot;,\\&quot;receiptsLegacy\\&quot;,\\&quot;hapi\\&quot;,\\&quot;mobile\\&quot;,\\&quot;moneyServices\\&quot;,\\&quot;pay\\&quot;,\\&quot;pharmacy\\&quot;,\\&quot;pickup\\&quot;,\\&quot;pin\\&quot;,\\&quot;purchaseHistory\\&quot;,\\&quot;savingsCatcherQuery\\&quot;,\\&quot;savingsCatcher\\&quot;,\\&quot;storeLocator\\&quot;,\\&quot;endlessAisle\\&quot;,\\&quot;www\\&quot;,\\&quot;pie\\&quot;],\\&quot;host\\&quot;:\\&quot;10.0.2.2:12000\\&quot;,\\&quot;isHttp\\&quot;:true},{\\&quot;services\\&quot;:[\\&quot;tfGraphql\\&quot;],\\&quot;host\\&quot;:\\&quot;https://10.0.2.2:12000/terra-firma/graphql\\&quot;, \\&quot;isHttp\\&quot;:true}]'&quot;,",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Training Guide/Android Automation/Desired Capabilities"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-201-setup-a-looper-job": {
        "title": "Setup a looper job",
        "content": "IntroductionSetup a looper jobConfig .looper.ymlBuild the looper jobLogin to looper systemOpen any link of https://ci.electrode.walmart.com/ or https://ci.walmart.com/, and login with your SSO credentialsCreate a looper jobConfig looper jobAfter create a empty looper job, you'll be automatically redirect to configuration page, drag down to Looper section, we'll do some essential configrations here.Config .looper.ymlNow you're on the page of the looper job you just created, you may see there's an issue hereThis is because the repo and branch you provided just now doesn't has a file named .looper.yml, now let's create one in your project, follow next chapter Config .looper.yml.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 201/Setup a looper job"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-201-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetup a looper jobConfig .looper.ymlBuild the looper jobWhat the TDK can do in a CI system?The native Android TDK can be easily integrated into a CI system, which usually is looper, by using the TDK in looper, user could done with Android Native tests in few simple steps.What you will know in this training?In this training, we'll go step by step from create a new looper job to run a looper build which execute native Android tests by the TDK, includes:Create a new looper job and config to a sample Android projectConfig .looper.yml in the boilerplate to make it connect looper VM with the TDKRun a looper build to see how the TDK works in looper",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 201/Introduction"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-201-config-looper-yml": {
        "title": "Config .looper.yml",
        "content": "IntroductionSetup a looper jobConfig .looper.ymlBuild the looper jobConfig .looper.yml in your projectFirst let's see how a minimum full config looks like:    inherit: 'job://otto-Android_native'    tools:        android:            - tools            - platform-tools            - android-25            - build-tools;25.0.1            - extras;android;m2repository        gradle: 4.2.1    envs:        global:            variables:                APK_PATH: ${YOUR_APK_PATH}                TEST_APK_PATH: ${YOUR_TEST_APK_PATH}                PACKAGE: ''                #ADMIRAL_PROJECT: Boilerplate Android                #FAIL_JOB_ON_TEST_FAIL: false    flows:        default:            - if not prepare apks, build them here, make sure they are under ${YOUR_APK_PATH} and ${YOUR_TEST_APK_PATH}            - shell (name run_tests): |                curl --header &quot;Authorization: token ${GH_API_TOKEN}&quot; \\                --header &quot;Accept: application/vnd.github.v3.raw&quot; \\                --location https://gecgithub01.walmart.com/api/v3/repos/otto/scripts/contents/looper/flank/flank.sh?ref=${BUILD_URL_REF} \\                | bashFirst, it's recommended that add inherit: 'job://otto-Android_native' at the first line of your .looper.yml it will handle all default envs for you if you missed some essential envs.Next add Android and Gradle tool stack in looper as described for Android tool and Gradle tool.Setup essential envs, reference by the env list, APK_PATH and TEST_APK_PATH is the two you must provided, FAIL_JOB_ON_TEST_FAIL is used when results chart plugin is installed in the looper job, and it needs the build at least passed once.If setup env ADMIRAL_PROJECT, e.g. Boilerplate Android, TDK will report to admiral2 dashboard after tests done, and you can check at http://admiral2.walmart.com/.Call looper flowsBuild your apk and test apk under the path same under env variablesCall TDK scripts as it is, recommend define your own GH_API_TOKEN.Last step, commit and push your .looper.yml to the repo, then let's goto Build the looper job.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 201/Config .looper.yml"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-201-build-the-looper-job": {
        "title": "Build the looper job",
        "content": "IntroductionSetup a looper jobConfig .looper.ymlBuild the looper jobReload looper modelNow let's go back to the looper job page, Click Reload looper model, you will see it works.Build the looper jobIt may run the first automatically, if it's not, click the buttion as thisSee the log output from hereSample outputAfter tests done, check the logs from TDK by click the step and read more in full logs.UI dashboardIf previously, you had setup ADMIRAL_PROJECT env in .looper.yml, after tests done, you could find your project and test results at http://admiral2.walmart.com/.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 201/Build the looper job"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-101-setup-and-steps": {
        "title": "Setup and steps",
        "content": "IntroductionSetup and stepsHow Flank worksAdvanced config of the TDKPrerequisitesInstall Node.js and NPM (npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer)To get the Walmart internal npm packages, you need to follow the steps: https://sde.walmart.com/docs/proximity/npm.html#downloading-packagesAchitecture and how it worksThe TDK connect with Google Firebase to run the tests on cloud based on the configuration provided like devices, shard etc. so in your Android project.Build projectNow we are ready to use Native Android TDK, it uploads built apks to Firebase to run tests, so we need to build the projects into apks, sample code:#!/usr/bin/env bash./gradlew assembleDebug./gradlew assembleDebugAndroidTestSetup authorization informationfirst we need setup authorization information by service-account.json file, the TDK script will create one for you, but you can always create a customized one, details at here.Setup Flank config informationAfter authorize to Google Cloud SDK, we are able to connect to Firebase, the next step we need is config Flank information by a file  config.properties under the root directory, all options listed at here, this will be explained at Advanced config of the TDK.Run testsWe have two ways to run the tests:Simply run Flank.jar which explained at Run Tests.Run TDK scriptexport essential envs and run the script.export GH_API_TOKEN=${YOUR_GITHUB_TOKEN}export APK_PATH=${APK_PATH}export TEST_APK_PATH=${TEST_APK_PATH}curl --header &quot;Authorization: token ${GH_API_TOKEN}&quot; \\--header &quot;Accept: application/vnd.github.v3.raw&quot; \\--location https://gecgithub01.walmart.com/api/v3/repos/otto/scripts/contents/looper/flank/flank.sh?ref=flank_beta \\ | bashThe TDK provides well organized scripts to handle all of works left based on files from above, steps in this phase will be explained in How Flank works.Post actionsDuring the process and after tests done, TDK will provdes detailed logs in the console and XML reports under ./results.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 101/Setup and steps"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetup and stepsHow Flank worksAdvanced config of the TDKWhat is native Android TDK?The functional native Android Test Development Kit (TDK) enables you to execute your native Android tests easily, reliably and quickly in the cloud. By using Flank which is part of the TDK, users can run their native Android tests in parallell on Firebase test lab in just a few steps.  The TDK will also provide a summarized diagram and logs for each test package and detailed XML test reports are shown in the job directly and also sent to our DI platform to track the results using the Test Armada dashboard.what you will know?In this training guide, you will learn how to setup Native Android TDK in your local environment, and how to run native android tests by default configurations via this TDK.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 101/Introduction"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-101-how-flank-works": {
        "title": "How Flank works",
        "content": "IntroductionSetup and stepsHow Flank worksAdvanced config of the TDKInstall and setup GCloud SDKFlank will download GCloud SDK, unzip and install it, to make sure all components in installation phase works, TDK sets proxy for GCloud SDK.Setup required envs by defaultTo make TDK works with essential components, Flank setup required envs by default, which could be easily override by user, env list at here.Download GCloud Auth json fileDownload default Auth info file which described at here, define your own auth json file and put the file url on Github to env SERVICE_ACCOUNT_URL.Auth GCloud SDKOnce the auth file is downloaded, it will auth the GCloud SDK by the info provided by the file.Install Flank.jar\bDownload Flank.jar to run tests by Flank.Initialize Flank configurationsThis step will check if any default/required configurations has not set, if so, the script will set them to default values.Run tests by FlankRun tests by Flank, and output all logs from Flank.Post results to Slack and UI dashboardAfter tests done, TDK will post the result xml files to designated Slack channel (#android_test by default) and TestArmada UI dashboard.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 101/How Flank works"
      },
    
      "documentation-functional-testing-native-android-java-training-guide-training-101-advanced-config-of-the-tdk": {
        "title": "Advanced config of the TDK",
        "content": "IntroductionSetup and stepsHow Flank worksAdvanced config of the TDKMake sure you have read the option list about Flank configurations.Then, in the config.properties in your root directory, customize your own properties.The essential part of the config is device, will combine with device name, version, orientation and locale, e.g.:devices=model:Nexus5X;version:23;orientation:portrait;locale:en,\\        model:Nexus6P;version:24,\\        model:NexusLowRes;version:26Another important feature is shard, the TDK help you shard proper tests to VMs, three options are recommended to be setshard-timeout: Timeout in minutes for each shard. 5 minutes by default.shard-duration: Duration in seconds for each shardnumShards: Number of shards to split the tests across. Unused by default.learn more at Configure Flank.If you need more logs when debugging, set debug-prints=true default is false.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Training Guide/Training 101/Advanced config of the TDK"
      },
    
      "documentation-performance-testing-rweb-declarative-introduction": {
        "title": "Introduction",
        "content": "SummaryAs a front end engineer, performance of your application becomes an essential measurement for your application to succeed. With evolving technologies and user-centric apps, it becomes very important to measure performance of your app before it gets released.  This is where our tool can help you to measure the performance of the app at every phase of your release cycles.The performace measurement toolThe OTTO’s client side performance measurement tool is based on Sitespeed and is currently serving Web and mWeb interfaces. We have plans to roll out client side performance testing for native apps (android and iOS) soon.Our test runner is a self-service solution for performance monitoring that could be easily and seamlessly integrated into the software development lifecycle (SDLC).Use CasesThis solution will help teams track performance over a matrix of code-bases, configurations, environments, etc.Here are a few use cases we envision:  Trigger performance measurement via command line interface (CLI);  Trigger performance measurement on pull request (PR);  Trigger performance measurement after deployment;  Schedule performance measurement;  Visualize performance reports;  Visualize how performance trend by release or over time;  Define performance budgets that could fail PRs or rollback deployments.ImpactOur test runner will empower developers and help them not only to prevent performance regressions but also to experiment and iterate faster, by squeezing every millisecond they can and ensuring their code is not a bottleneck.It can also help find hot spots and provide insight from application, to page and component levels.ArchitectureOur test solution will integrate and orchestrate multiple components to measure performance according to many scenarios:  Application and mocking servers;  Synthetic users;  Runtime instrumentation and payload rewriting;  Network link conditioning.At a very high level, system architecture:Feature list  Integrates with your CI pipeline to run performance tests as you merge code in Git repo.  Provides reporting in time series data which can be visualized to see the trend of your application in development phase itself.  Laboratory conditions: the tests run in a very restricted environment so that we can rely on the test results without worrying about the noise that can come from network delays, CPU or memory resources. The environment are carefully monitored for any other latency or resource conflicts that may affect the performance test results.  Framework Independent:  If your app is a NodeJS app, our tool will seemlessly measure your performance. It does not matter if your app is React, Angular, Vue or any other framework.  Local Execution : a local version can be used to run tests on your development machine before you check in code.  Mock Server Integration : Tests can be run with a mock server to provide a noise-free testing.  This is an optional feature.  You can remove the mock server if you need to do live server testing, eg. production or stage testing.  Runs for Chrome and Firefox browsers.Metrics collectedOur performace tool collects metrics from the browser API via sitespeed.io. Most of the browsers have a performance API which can be used to capture the performance measurements of an app. Sitespeed.io captures these metrics and provides a metric data which is then transformed into a readable data.Navigation API:  responseTime (TTFB)  backendTime  frontendTime  redirectionTime  dnsLookUpTime  serverConnection  serverResponse  firstPaint  rumSpeedIndex  domContentLoadEventStart  domContentLoadEventEnd  domInteractive  pageLoad  fullyLoadedAssets:  Html content size  Image content size  Javascript content size  Font content size  CSS content size  SVG content size  Cookie size  Total Header size  Total content transfer sizeCustom metrics: (These are added by the app teams on their pages, few examples are below)  aboveTheFold  beforeBundle  afterBundle  index_start  first_script  entrypoint  loadHTTP status codes:  Number of 404 response codes  Number of 200 response codesOther metrics:  number of domains  last modified stats# Planned Features  Looper integration  mweb support  native supportCustomers  R-Discovery/Homepage  R-Discovery/EasyReOrder  R-Discovery/Collections  R-Discovery/Product  R-Discovery/Non-Config  R-User/Account  R-User/Login  R-CAT/Topic  R-search-category/category  R-Transaction/Cart  R-Transaction/Checkout",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/Introduction"
      },
    
      "documentation-performance-testing-rweb-declarative-getting-started": {
        "title": "Getting Started",
        "content": "IntroductionOur side performance measurement tool that is based on Sitespeed and is currently serving Web and mWeb interfaces.Test Plan creationFirst you need to fill in Repository Branch and a name for your Test Plan. Fill in Test Type and Platform. For client performance Sitespeed test, please select rWeb.Next, fill in App Build command, App Server start command, number of runs and optionally Mocking Server start command. Currenly, only CI triggers are supported and you have a choice between PR to Branch (tests are run when a PR to merge into your Branch is opened) and Merge to Branch (tests are run on any commit to your Branch).You can now see the newly created Performance Test Plan on the project dashboard. Here you have a link to a Looper job associated with this test plan as well as Gighub link for your project on the top bar accross from project name. Click on View Reporting to view test results.Test resultsEach test run will result in a new set pf datapoints on the results page and a new SiteSpeed report in the bottom section of the report. You will be able to see how particular metric changes between test runs.",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/Getting Started"
      },
    
      "documentation-performance-testing-rweb-declarative-faq": {
        "title": "FAQ",
        "content": "What advantages does Rapido provide over other online performance tools?_Answer:_ Here are few advantages : - Rapido provides performanc testing as a part of Contionous Delivery, that is, it integrates with your repo and runs performance tests as part of PR Verify, Master Verify or scheduled build.- Rapido gives you an ability to catch the performance regressions of your app right at the gate, which gives you an opportunity to fix any performance bugs where it can be fixed easily.- Rapido provides an infrastructure to run web and mweb performance tests in Walmart's environment. The set up is done in Walmart's oneops environment which enables easy integration and on-boarding of any new projects. - Provides data transformation tools and and visualization which comes with the package when you on-board on Rapido.  - Easy set up, onboarding takes around 2 hours.- Rapido runs the tests in laboratory conditions, meaning, they run on VMs which are monitored for resources (CPU, memory, and network resources). We make sure that the VMs are isolated and are not affected by any noise that affect the tests. How long does it take to onboard on Rapido?- Around 2-3 hours if you are an electrode project.Can I run Rapido in my local environment?- Yes, Rapido can be executed on your local by simply following the above instructions.  You can also use   https://gecgithub01.walmart.com/rapido/rapido_local to run rapido locally. This repo has interactive features available which sets up rapido on its own to get a head start.Are the performance tests reliable?- Performance tests are results recieved from the browser API itself. There could be few variances in some of the metrics delivered by sitespeed.io, but mostly the results are reliable when you run the tests with a mock server serving your application. We have seen large variances when a live backend is used for testing and that is because of obvious reasons.  That being said, we understand that performance, for many teams, would mean running tests on whole application with backened services involved. We provide following recommendations when it comes to running web performance tests :  - PR Verify for front end code  - Run with mock server  - Master Verify for front end code - Run with mock server  - Prod Verify for front end code - Run without mock server.Please note that the Prod verify tests will have more flakiness in metrics becasue they will be affected by various factors, for example, network delays, geographical location, network speed and availability of third party content. The production tests can give you an idea of how your application is performing in the production and you can look for big fluctuations on the metrics to give you an idea if anything bad is happening with your application.How is Rapido results different from Real User Metrics (RUM) results?- RUM metrics are measurements which are captured by beacon data when real users browse and perform click actions on the production website. Rapido metrics are measurements produced by synthetic performance testing, in which we create an environment for testing and run the application performance test in tighly monitored environment.  While RUM data is very useful for measuring the performance of your website in real world, it is a completely different measurements from the metrics produced in synthetic testing.  The reasons are obvious, testing in real world brings a lot of factors into play. Some of them are : network availability, geographic location, device resources etc.  In case of synthetic testing, the motive of testing is itself very different. The motivation here is to test performance of the app before it goes out in the real world. This  provides us an opportunity to fix the performance regressions before they are used by real users.",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/FAQ"
      },
    
      "documentation-performance-testing-rweb-declarative-contribution-guide": {
        "title": "Contribution Guide",
        "content": "You are welcome to contribute to our repo. Our main repos are :  https://gecgithub01.walmart.com/rapido/operaio  https://gecgithub01.walmart.com/rapido/plugin-sitespeed  (captures the data from sitespeed and saves it in kairos db)  https://gecgithub01.walmart.com/rapido/annesso (transforms the sitespeed.io result data to be kairos compatible)Below is the architecture of how the components of rapido interact with each other:Understanding Rapido Process Flow in Jenkins:. A Jenkins job is triggered by a change in the application’s repository :  That job can only run in a specific set of slaves, provisioned to run performance jobs;  These slaves are OneOps VMs that include Docker engine, a command line tool named operaio and the following Docker images:          electrode-app-builder;      otto-mock-server: runs the mocking server from the source stored in a given volume;      electrode-app: runs the application from the source stored in a given volume;      sitespeed.io: measures application performance;      1. operaio takes a few arguments from the Jenkins jobs and automates the performance measurement workflow;       1. A Docker container is started from an electrode-app-builder image, where:        1. Application source is pulled from GitHub;        1. Dependencies are installed via npm install;        1. Application is built via command provided by app team. As an example NODE_ENV=production npm run build;        1. Result is made available to specified volume;      1. A Docker container is started from an otto-mock-server image, where the mock server is started via npm run mock-server;      1. A Docker container is started from an electrode-app image, where:        1. Environment variables tell the application to run optimized code against mocked services, example:      NODE_ENV=production      NODE_APP_INSTANCE=mock        1. The host dev.walmart.com is mapped to otto-mock-server’s IP;        1. Application is started command provided by app team. As an example,  node server/index.js or npm run start      1. A Docker container is started from a sitespeed.io image, which uses Chrome browser to measure performance from the electrode-app container;      1. The collected metrics are forwared to a KairosDB cluster, which is backed by a Cassandra cluster;      1. The collected HAR files are stored into the Cassandra cluster;      1. The sitespeed.io container stops and cleans up;      1. Other containers are stopped and cleaned-up:        electrode-app;  otto-mock-server;  electrode-app-builder;          Job stops and Jenkins slave is freed-up;      The results can visualized from a Grafana dashboards hosted at https://prod.rapido.walmart.com/;      Our main modules where you can contribute :      Operaio (https://gecgithub01.walmart.com/rapido/operaio) - This is the runner of the performance tests. It basically starts all the docker containers : electrode-app-builder, electrode-app, otto-mock-server and sitespeed.io to run the performance tests and deliver the test resuls to the kairos db.  If you need to change the way process runs, please contribute to this project.        Plugin-sitespeed (https://gecgithub01.walmart.com/rapido/plugin-sitespeed) - This is the module which captures the data from sitespeed.io and passes it along to annesso module to transform the data and publish it to the Kairos db        Annsesso  (https://gecgithub01.walmart.com/rapido/annesso)  - This is the module which transforms the sitespeed results data and does a POST to Kairos db to publish the data.  Contributors are encouraged to make changes and write test cases for any new functionality introduced.",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/Contribution Guide"
      },
    
      "documentation-performance-testing-rweb-declarative-boilerplates": {
        "title": "Boilerplates",
        "content": "Rapido Versions      Rapido for Jenkins:  Rapido for Jenkins uses modules Operaio.  To download an example project please go here        Rapido for local:  If you want to run performance tests on your local machine, you can checkout the repo. This repo lets you run performance test in your machine. This way you can get an idea of your application before you check in the code in repo.  ",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/Boilerplates"
      },
    
      "documentation-performance-testing-services-declarative-upcoming-features": {
        "title": "Upcoming Features",
        "content": "Upcoming Features  Support to run adhoc performance tests outside of CI pipeline using single load generator  Enhancements on performance test results trends and analytics around performance metrics  Auto generation of Jmeter test plans for service level tests  Dynamic vusers ramp up &amp; ramp down  Test scheduling  Diagnostic features for getting thread and heap dumps through",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/Upcoming Features"
      },
    
      "documentation-performance-testing-services-declarative-introduction": {
        "title": "Introduction",
        "content": "SummaryThe backend Performance testing that is part of the Performance Testing fleet of Test Armada is based on JMeter. This solution has been developed in-house and built entirely on open source components. It enables any developer to execute performance tests on their own and view the detailed test results real time on the self service portal. It allows engineers to develop and/or modify tests quickly and easily thereby saving the overall time taken to create and execute any type of performance tests.Key Features•\tAll advantages of Apache JMeter without the overhead of test infrastructure.•\tRun any JMeter test plan regardless of test complexity as long as it needs one load generator.•\tBuilt-in integration with Looper for CI Performance.•\tLive results view for all transactions in the test plan.•\tView live test logs from test execution on Splunk.•\tAdditional performance metrics like hits/sec, throughput per transaction, error rate on results dashboard.•\tView test results by each run.•\tPerformance Test results trend and historical test results available on Data Insights.",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/Introduction"
      },
    
      "documentation-performance-testing-services-declarative-getting-started": {
        "title": "Getting Started",
        "content": "JMeter Test Plan creation steps  Download the customized version of jmeter from getLatestVersionOfJmeter.  Add the Thread Group where you can specify number of threads, rampup time and test duration.  Add HTTP sampler request for every request and CSV data config element for test data set up  Add Timers if you want to introduce think times between each transaction.  Add KafkaBackendListener to stream all test results into the Data Insights module. This custom JMeter plugin is bundled into the custom JMeter downloaded in step 1 above. Follow these steps to add the Kafka Listener.a.\tClick on testplan–&gt;Add–&gt;Listener–&gt;Backend Listener. b.\tSelect kafkaplugin.KafkabackendListenerClient from the drop down list in Backend Listener Implementation.c.\tUpdate summaryOnly parameter to false.  Save the JMX.   The test plan should not have other Listeners to generate reports like Aggregate Report, Summary Report. These listeners are resource intensive and can significantly impact the load generation capabilities for the test agent machine. Easy Onboarding Tips  Before creating TestPlan on TestArmada.,ensure that user:SVCgecfeops is added to your GitHub project repo as Collaborators.   Ensure that your tests and their artifacts are structured as shown below:Do note that the folders are named as per type of performance test. If your project is onboarded on the self service portal, creating new tests is as simple as entering the folder name of your new testResults Dashboard  Response Time trend: This would give me average response time for all the transaction.    Comparison of percentage distribution of successful transaction v/s failed transactions.”ok” represents successful and “ko” represents failed.    Transaction Rate: Trend rate comparison between successful and failed transaction.    Response Throughput: Trend of network throughput for various transaction.    Hits/sec or Transaction/sec(TPS):Trend of transactions per sec for various transactions. ",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/Getting Started"
      },
    
      "documentation-performance-testing-services-declarative-faqs": {
        "title": "FAQs",
        "content": "FAQs1.\tWhere can I store my JMeter test artifacts? Jmeter test artifacts should be in your project repository under the test/performance folder as depicted in the image:2.\tRunning my test errors out or does not produce results. How do I debug? Ensure the location of JMX complies to the diagram above and the Kafka Listener is added to your test plan. Without the Kafka listener, the results will not flow into the Data Insights module.3.\tI have developed custom plugin for my test. How do I get this on my load agents?Dedicated load agents are required for any customization. Reach out to the Otto team on #testautomation channel to create dedicated agent and to add custom plugins to it.4.\tI have custom jars I use in my test client. How do I add these to my load agents?Dedicated load agents are required for any customization. Reach out to the Otto team on #testautomation channel to create dedicated agent and to add custom jar files to it.5.\tI want to use custom listeners to stream test results to my database. How do I do that?This is not supported on the Test Armada platform. We mandate all tests run on our platform stream results into Data Insights module.6.\tI want to use only the Data Insights module of Test Armada to maintain my test results. How can I do this?This is possible after Q3 of FY19. Reach out to Otto team on #testautomation channel for more details.7.\tCan I use my own JMeter load agents?Yes you can. Test agents in our internal data centers can be added and tied to your project. Your load agents will have to use JMeter available for download on getLatestVersionOfJmeter.8.\tCan I run performance tests from load agents in public cloud?Currently we do not have test agents setup in public cloud. This is in our roadmap for Q3 &amp; Q4 of FY19 to have agents setup in three US regions.9.\tCan I get help with JMeter scripting?Debugging and troubleshooting help with existing scripts is possible. Test Armada team does not undertake new scripting work.",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/FAQs"
      },
    
      "documentation-performance-testing-services-declarative-best-practices": {
        "title": "Best Practices",
        "content": "JMeter Scripting best practices  Avoid excessive logging as it severely impacts the throughput of load agents. Restrict your logging to error conditions only.  Total number of users in the test plan is per load agent. Number of users defined in the test plan and the number of load agents used is what defines the total number of users in the test.  JMeter versions are not forward compatible. To avoid compatibility issues, download the JMeter bundle from TestArmada self-service portal.  For web-based application testing, do not download the static assets on the pages. These assets are downloaded from CDN or are served from a separate web server which do not have any bearing on the application under test. Enabling this will significantly impact the test results and throughput of load agents.  Choose think time and pacing time between two successive transactions wisely. This is essential for mimicking real time usage.  For service level performance testing, think time and pacing time do not matter much as the focus of testing is on application throughput and latency.  JMeter captures response times for all calls within a transaction including individual API calls. Wrapping sub-transactions around each call within a transaction is not required.  Avoid unnecessary pre and post processors as they consume resources on the load agent  Randomize selection of test data from data files for unique data in each iteration. JMeter controllers do not assign unique test data to each user as is the case with few other tools.Execution best practices  Avoid running JMeter console on your desktop or any machine on the corpnet. This will produce inaccurate results. JMeter console should only be used to unit test your scripts by running with 2 or more users.  Limit the number of virtual users to a maximum of 300 per load agent. Assumption here is the agent runs on a large VM and does not have any memory intensive computation within the script.  View Results tree listener should be disabled as results are available in the portal  Do not add any listeners to your script other than the specified Kafka listener. This is essential to view live results during the course of test execution.  Disable all graphs and JTL file generation from your test plan. Test results can be viewed live in the portal and the same is archived in the Data Insights DB.  Monitor test logs and test agent resource utilization for your test on the links below:a.\tSplunk: http://dfw-logsearch01.prod.walmart.com b.\tMedusa: https://medusa.walmart.com/   Save test logs locally from Splunk if you need it beyond 14 days from the execution date ",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/Best Practices"
      },
    
      "mocking-rweb-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/rWeb/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-rweb-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments. The solution is being used by more than 70+ teams across different organizations within Walmart.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UICustomersThe following teams are using mocking service to mock their backend services during functional testing as well as during development.  Home  Easy Reorder  Product  Back To School  Reviews  NonConfig  Product  Store Finder  Thank You  Cart  Checkout  Lists  Sams Product  Sams Cart  Sams Checkout  Sams Join Now  Account  Customer Care  Smart Pay  Unified Login  Store Checkin  Store Ereceipt  Store Pharmacy Pay  Store Savings Catcher  Pharmacy Account  Search Tools  Tempo  TangoAnd more !!!",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-rweb-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.js  The application needs to install npm modules from an internal repository. Add a file named .npmrc in the root of your project. Follow this npm guide to know more about .npmrc file.Setting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"@walmart/shifu\": \"^3.0.7\",   \"@walmart/shifu-magellan-nightwatch\": \"^2.0.2\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('@walmart/shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('@walmart/shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).       metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu',    metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-rweb-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)  If inside of Walmart you need npm access to the internal nexus/npm repoHow Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"@walmart/shifu\": \"3.0.4\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});Why do I see No routes defined for this path ?Any undefined routes in Shifu will be responsed with a user friendly message No routes defined for this path.How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;    if(authorization) {       // do something    }    reply().code(204);  }}); How To Read Payload In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How to read url parameters in request ?To read the dynamic URL parameters in request with in the route, use request.paramsvar shifu = require('@walmart/shifu');shifu.route({  path: '/api/customer/{id}'  handler: function(req, reply) {    // would be \"123\" if the endpiont hit was \"/api/customer/123\"    var id = request.params.id;  }});How to add delay to response?A mocked response can also be delayed by some time specified by the user. You can simulate a delay (in ms) by passing delay as follows :shifu.route({  id: 'message',  label: 'Hello Variants',  path: '/message',  variantLabel: 'hello world',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply, {code: 202});  }}).variant({    id: 'variant with delay',    label: 'variant with delay',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {filePath: './message/GET/variant_with_delay.json', delay: 1000});    }  });How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate WayTo set custom headers, call header(name, value, options) on reply object, wherename is the header namevalue is the header valueoptions is an optional object with the following attributes            Attribute      Description                  append      if true, the value is appended to any existing header value using separator. Defaults to false.              separator      string used as separator when appending to an exiting value. Defaults to ','              override      if false, the header value is not set if an existing value present. Defaults to true              duplicate      if false, the header value is not modified if the provided value is already included. Does not apply when append is false or if the name is ‘set-cookie’. Defaults to true      shifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate WayTo set custom cookies, call state(name, value, options) on reply object, where name is the cookie namevalue is the cookie valueoptions is the server state options settings found hereshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?The Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web application running inside a browser which are loaded from a different domain than the API server. CORS headers are disabled by default. To enable, set cors to true, or to an object with the following options:            Option      Description                  origin      a string array of allowed origin servers Access-Control-Allow-Origin. Defaults to any origin [‘*’]              maxAge      number of seconds the browser should cache the CORS response (‘Access-Control-Max-Age’). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to 86400 (one day).              headers      string array of allowed headers Access-Control-Allow-Headers. Defaults to ['Authorization', 'Content-Type', 'If-None-Match'].              additionalHeaders      string array of additional headers to headers. Use this to keep the default headers in place.              methods      string array of allowed HTTP methods Access-Control-Allow-Methods. Defaults to ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']              additionalMethods      string array of additional methods to methods. Use this to keep the default methods in place              exposedHeaders      string array of exposed headers Access-Control-Expose-Headers. Defaults to ['WWW-Authenticate', 'Server-Authorization'              additionalExposedHeaders      a string array of additional headers to exposedHeaders. Use this to keep the default headers in place.              credentials      if true, allows user credentials to be sent Access-Control-Allow-Credentials. Defaults to false.      var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('@walmart/shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dCan I reset all variants for all the routes?Yes. Please refer resetAllVariants in API guide section.What Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read thisHow to send meta information for response ?Mocked responses can also have meta information that can be set in the response files itself. For example :{  \"setHeaders\": {    \"date\": \"Fri, 06 Jan 2017 03:33:22 GMT\",    \"content-type\": \"text/html; charset=UTF-8\",    \"transfer-encoding\": \"chunked\",    \"connection\": \"close\",    \"set-cookie\": [      \"__cfduid=d7502270409ade5544a5a60d0fbd7652a1483673602; expires=Sat, 06-Jan-18 03:33:22 GMT; path=/; domain=.typicode.com; HttpOnly\"    ],    \"x-powered-by\": \"Express\",    \"vary\": \"Accept-Encoding\",    \"access-control-allow-credentials\": \"true\",    \"cache-control\": \"public, max-age=14400\",    \"last-modified\": \"Thu, 05 Jan 2017 07:28:00 GMT\",    \"via\": \"1.1 vegur\",    \"cf-cache-status\": \"HIT\",    \"expires\": \"Fri, 06 Jan 2017 07:33:22 GMT\",    \"server\": \"cloudflare-nginx\",    \"cf-ray\": \"31cc1baee47b11fb-SJC\"  },  \"setCode\":201,  \"setPayload\": \"resources/mocked-data/message/GET/file_read_from_recorded_file.txt\",  \"setContentType\": \"text/plain; charset=utf-8\"}The above file is going to set the headers of the response from Shifu according to headers provided in setHeaders, code provided in setCode , contentType provided in setContentType and payload provided in setPayload. If setPayload is a path of the file intended to be responded with, then Shifu will look for the file and respond with the content of that file. If setPayload is JSON content, then Shifu will respond with JSON content.The above functionality makes sure that Shifu is able to handle all the file types when responding with recorded mocked data.In order to test different scenarios, you can add/delete/update header information in the setHeaders value. Or if you need to change the contentType of the response, you can simply replace value of setContentType.Please note that setContentType will take precedence over content-type header value. If setContentType is not provided then, HTTP will set the contentType of the file according to file type.How to add Shifu custom commands to Nightwatch?To add mock server custom commands to control the Shifu server in your end to end tests, add the following in nightwatch.json:\"custom_commands_path\": [    ...    \"./node_modules/shifu-magellan-nightwatch/commands\"  ],",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-rweb-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js which can look something like this        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Gec Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Proxy  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      git clone git@gecgithub01.walmart.com:otto/shifu.git        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (2) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request against the development branch. The Looper build triggers a PR Verify build which runs the tests in CI environment (same steps as in (4) above).        Once the PR is reviewed , a team member merges the PR into the development branch.        When the development branch is merged to master, the Master Verify build is triggered and publishes a new version of the package to Walmart’s npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-rweb-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Boilerplate with a web appThis boilerplate application is a web app built using Walmart’s public APIs to locate stores near a zip code. The responses are mocked using the Mock Server.      To run against live-service, use the following commad:    npm run start-live        To run against mock-service, use the following commad:    npm run start-mock  More details could be found in the README for the boilerplateParallel Sessions boilerplate/demoThis Boilerplates starts a mock server and demonstrates how the same rest end point could be used to return different datasets while running test cases in parallel. In this example, two test cases execute in parallel and access the Rest endpoint /api/homepage after setting two different variants on the same route using sessions.Test cases receives mocked html responses, one for jet.com homepage and other for walmart.com homepage.Project ReferenceThis is an actual project for your reference from Discovery team that uses mock server to run test cases.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-mocking-rweb-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Start Mock Server - start()  Stop Mock Server - stop()  Create Mocked Route - route()  Create Variant - variant()  Set variant - setMockVariant()  Reset all variants - resetAllVariants()          Without sessions      With sessions        Add global variants - addGlobalVariant()  Respond With File - respondWithFile()  Respond with mock variant - respondWithMockVariant()  Set Mock Id - setMockId()  Get Mock Id - getMockId()  Reset Mock Id - resetMockId()  Reset url count - resetURLCount()  Get url count - getURLCount()  Register session - registerSession()  Close session - closeSession()  Check session - checkSession()  Get sessions - getSessions()  Clear sessions - clearSessions()  Get project name - getProjectName()  Get port information - getPortInfo()  Add state - addState()  Get state - getState()  Clear state - clearState()  Enable Metrics - enableMetrics()  Check if metrics are enabled - isMetricsEnabled()  Dynamic transposition of JSON data - transposeData()  Kill process - killProcess()  Read contents of a file - readFile()  Read contents of a file - readFileSynchronously()  Read contents of JSON file - readJsonFile()  Write to file - writeFile()  Delete file - deleteFile()  Check if directory exists - checkDirectoryExists()  Check if file exists - checkFileExists()  Set Log level - setLogLevel()  Get Log level - getLogLevel()  Reset Log level - resetLogLevel()Start Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No              metricsDB      The database url where mock server posts usage metrics to  default: http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints      No      Examplevar shifu = require('@walmart/shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('@walmart/shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"universe\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Reset all variants - resetAllVariants()resetAllVariants can be used to reset all the variants for all routes for a given session id to default.shifu.resetAllVariants(shifuSessionId, callback) // with Shifu libraryor browser.resetAllVariants(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Session id for which all variants for all routes are to be set to default      No              callback      callback function to be called after resetAllVariants()      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});shifu.route({  id: 'hi',  path: '/hiWorld',  handler: function(request, reply) {    reply('Hi World');  }}).variant({  id: 'galaxy',  handler: function(request, reply) {    reply('Hi Galaxy');  }});Without sessionsWhen not using the sessions feature, you don’t need to send the shifuSessionId parameter. By default, resetAllVariants sets all the variants for all the routes to default for the default session.For the above routes, if the variant universe is set for the path helloWorld and variant galaxy is set for the path hiWorld, all the variants can be set to default for both these routes in this way:shifu.resetAllVariants(function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants();Alternately, you can also use curl call to set a variant with this POST call to `{host}:{port}/shifu/api/resetAllVariantscurl -X GET  http://localhost:8080/shifu/api/resetAllVariantsWith sessionsFor the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu library// shifuSessionId is a valid registered session with Shifushifu.resetAllVariants(shifuSessionId, function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants(shifuSessionId);Alternately, you can also use curl call to set a variant with this POST call to {host}:{port}/shifu/api/resetAllVariants/{shifuSessionId}curl -X GET  http://localhost:8080/shifu/api/resetAllVariants/{shifuSessionId}Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('@walmart/shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('@walmart/shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('@walmart/shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('@walmart/shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('@walmart/shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('@walmart/shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('@walmart/shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('@walmart/shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('@walmart/shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('@walmart/shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('@walmart/shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('@walmart/shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('@walmart/shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('@walmart/shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('@walmart/shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('@walmart/shifu);shifu.log.getLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('@walmart/shifu);shifu.log.resetLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/API Guide"
      },
    
      "mocking-services-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Services/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-services-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments. The solution is being used by more than 70+ teams across different organizations within Walmart.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UICustomersThe following teams are using mocking service to mock their backend services during functional testing as well as during development.  Home  Easy Reorder  Product  Back To School  Reviews  NonConfig  Product  Store Finder  Thank You  Cart  Checkout  Lists  Sams Product  Sams Cart  Sams Checkout  Sams Join Now  Account  Customer Care  Smart Pay  Unified Login  Store Checkin  Store Ereceipt  Store Pharmacy Pay  Store Savings Catcher  Pharmacy Account  Search Tools  Tempo  TangoAnd more !!!",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-services-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.js  The application needs to install npm modules from an internal repository. Add a file named .npmrc in the root of your project. Follow this npm guide to know more about .npmrc file.Setting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"@walmart/shifu\": \"^3.0.7\",   \"@walmart/shifu-magellan-nightwatch\": \"^2.0.2\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('@walmart/shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('@walmart/shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).       metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu',    metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-services-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)  If inside of Walmart you need npm access to the internal nexus/npm repoHow Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"@walmart/shifu\": \"3.0.4\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});Why do I see No routes defined for this path ?Any undefined routes in Shifu will be responsed with a user friendly message No routes defined for this path.How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;    if(authorization) {       // do something    }    reply().code(204);  }}); How To Read Payload In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How to read url parameters in request ?To read the dynamic URL parameters in request with in the route, use request.paramsvar shifu = require('@walmart/shifu');shifu.route({  path: '/api/customer/{id}'  handler: function(req, reply) {    // would be \"123\" if the endpiont hit was \"/api/customer/123\"    var id = request.params.id;  }});How to add delay to response?A mocked response can also be delayed by some time specified by the user. You can simulate a delay (in ms) by passing delay as follows :shifu.route({  id: 'message',  label: 'Hello Variants',  path: '/message',  variantLabel: 'hello world',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply, {code: 202});  }}).variant({    id: 'variant with delay',    label: 'variant with delay',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {filePath: './message/GET/variant_with_delay.json', delay: 1000});    }  });How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate WayTo set custom headers, call header(name, value, options) on reply object, wherename is the header namevalue is the header valueoptions is an optional object with the following attributes            Attribute      Description                  append      if true, the value is appended to any existing header value using separator. Defaults to false.              separator      string used as separator when appending to an exiting value. Defaults to ','              override      if false, the header value is not set if an existing value present. Defaults to true              duplicate      if false, the header value is not modified if the provided value is already included. Does not apply when append is false or if the name is ‘set-cookie’. Defaults to true      shifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate WayTo set custom cookies, call state(name, value, options) on reply object, where name is the cookie namevalue is the cookie valueoptions is the server state options settings found hereshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?The Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web application running inside a browser which are loaded from a different domain than the API server. CORS headers are disabled by default. To enable, set cors to true, or to an object with the following options:            Option      Description                  origin      a string array of allowed origin servers Access-Control-Allow-Origin. Defaults to any origin [‘*’]              maxAge      number of seconds the browser should cache the CORS response (‘Access-Control-Max-Age’). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to 86400 (one day).              headers      string array of allowed headers Access-Control-Allow-Headers. Defaults to ['Authorization', 'Content-Type', 'If-None-Match'].              additionalHeaders      string array of additional headers to headers. Use this to keep the default headers in place.              methods      string array of allowed HTTP methods Access-Control-Allow-Methods. Defaults to ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']              additionalMethods      string array of additional methods to methods. Use this to keep the default methods in place              exposedHeaders      string array of exposed headers Access-Control-Expose-Headers. Defaults to ['WWW-Authenticate', 'Server-Authorization'              additionalExposedHeaders      a string array of additional headers to exposedHeaders. Use this to keep the default headers in place.              credentials      if true, allows user credentials to be sent Access-Control-Allow-Credentials. Defaults to false.      var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('@walmart/shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dCan I reset all variants for all the routes?Yes. Please refer resetAllVariants in API guide section.What Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read thisHow to send meta information for response ?Mocked responses can also have meta information that can be set in the response files itself. For example :{  \"setHeaders\": {    \"date\": \"Fri, 06 Jan 2017 03:33:22 GMT\",    \"content-type\": \"text/html; charset=UTF-8\",    \"transfer-encoding\": \"chunked\",    \"connection\": \"close\",    \"set-cookie\": [      \"__cfduid=d7502270409ade5544a5a60d0fbd7652a1483673602; expires=Sat, 06-Jan-18 03:33:22 GMT; path=/; domain=.typicode.com; HttpOnly\"    ],    \"x-powered-by\": \"Express\",    \"vary\": \"Accept-Encoding\",    \"access-control-allow-credentials\": \"true\",    \"cache-control\": \"public, max-age=14400\",    \"last-modified\": \"Thu, 05 Jan 2017 07:28:00 GMT\",    \"via\": \"1.1 vegur\",    \"cf-cache-status\": \"HIT\",    \"expires\": \"Fri, 06 Jan 2017 07:33:22 GMT\",    \"server\": \"cloudflare-nginx\",    \"cf-ray\": \"31cc1baee47b11fb-SJC\"  },  \"setCode\":201,  \"setPayload\": \"resources/mocked-data/message/GET/file_read_from_recorded_file.txt\",  \"setContentType\": \"text/plain; charset=utf-8\"}The above file is going to set the headers of the response from Shifu according to headers provided in setHeaders, code provided in setCode , contentType provided in setContentType and payload provided in setPayload. If setPayload is a path of the file intended to be responded with, then Shifu will look for the file and respond with the content of that file. If setPayload is JSON content, then Shifu will respond with JSON content.The above functionality makes sure that Shifu is able to handle all the file types when responding with recorded mocked data.In order to test different scenarios, you can add/delete/update header information in the setHeaders value. Or if you need to change the contentType of the response, you can simply replace value of setContentType.Please note that setContentType will take precedence over content-type header value. If setContentType is not provided then, HTTP will set the contentType of the file according to file type.How to add Shifu custom commands to Nightwatch?To add mock server custom commands to control the Shifu server in your end to end tests, add the following in nightwatch.json:\"custom_commands_path\": [    ...    \"./node_modules/shifu-magellan-nightwatch/commands\"  ],",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-services-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js which can look something like this        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Gec Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Proxy  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      git clone git@gecgithub01.walmart.com:otto/shifu.git        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (2) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request against the development branch. The Looper build triggers a PR Verify build which runs the tests in CI environment (same steps as in (4) above).        Once the PR is reviewed , a team member merges the PR into the development branch.        When the development branch is merged to master, the Master Verify build is triggered and publishes a new version of the package to Walmart’s npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-services-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Boilerplate with a web appThis boilerplate application is a web app built using Walmart’s public APIs to locate stores near a zip code. The responses are mocked using the Mock Server.      To run against live-service, use the following commad:    npm run start-live        To run against mock-service, use the following commad:    npm run start-mock  More details could be found in the README for the boilerplateParallel Sessions boilerplate/demoThis Boilerplates starts a mock server and demonstrates how the same rest end point could be used to return different datasets while running test cases in parallel. In this example, two test cases execute in parallel and access the Rest endpoint /api/homepage after setting two different variants on the same route using sessions.Test cases receives mocked html responses, one for jet.com homepage and other for walmart.com homepage.Project ReferenceThis is an actual project for your reference from disocery team that uses mock server to run test cases.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-mocking-services-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Start Mock Server - start()  Stop Mock Server - stop()  Create Mocked Route - route()  Create Variant - variant()  Set variant - setMockVariant()  Reset all variants - resetAllVariants()          Without sessions      With sessions        Add global variants - addGlobalVariant()  Respond With File - respondWithFile()  Respond with mock variant - respondWithMockVariant()  Set Mock Id - setMockId()  Get Mock Id - getMockId()  Reset Mock Id - resetMockId()  Reset url count - resetURLCount()  Get url count - getURLCount()  Register session - registerSession()  Close session - closeSession()  Check session - checkSession()  Get sessions - getSessions()  Clear sessions - clearSessions()  Get project name - getProjectName()  Get port information - getPortInfo()  Add state - addState()  Get state - getState()  Clear state - clearState()  Enable Metrics - enableMetrics()  Check if metrics are enabled - isMetricsEnabled()  Dynamic transposition of JSON data - transposeData()  Kill process - killProcess()  Read contents of a file - readFile()  Read contents of a file - readFileSynchronously()  Read contents of JSON file - readJsonFile()  Write to file - writeFile()  Delete file - deleteFile()  Check if directory exists - checkDirectoryExists()  Check if file exists - checkFileExists()  Set Log level - setLogLevel()  Get Log level - getLogLevel()  Reset Log level - resetLogLevel()Start Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No              metricsDB      The database url where mock server posts usage metrics to  default: http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints      No      Examplevar shifu = require('@walmart/shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('@walmart/shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"universe\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Reset all variants - resetAllVariants()resetAllVariants can be used to reset all the variants for all routes for a given session id to default.shifu.resetAllVariants(shifuSessionId, callback) // with Shifu libraryor browser.resetAllVariants(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Session id for which all variants for all routes are to be set to default      No              callback      callback function to be called after resetAllVariants()      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});shifu.route({  id: 'hi',  path: '/hiWorld',  handler: function(request, reply) {    reply('Hi World');  }}).variant({  id: 'galaxy',  handler: function(request, reply) {    reply('Hi Galaxy');  }});Without sessionsWhen not using the sessions feature, you don’t need to send the shifuSessionId parameter. By default, resetAllVariants sets all the variants for all the routes to default for the default session.For the above routes, if the variant universe is set for the path helloWorld and variant galaxy is set for the path hiWorld, all the variants can be set to default for both these routes in this way:shifu.resetAllVariants(function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants();Alternately, you can also use curl call to set a variant with this POST call to `{host}:{port}/shifu/api/resetAllVariantscurl -X GET  http://localhost:8080/shifu/api/resetAllVariantsWith sessionsFor the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu library// shifuSessionId is a valid registered session with Shifushifu.resetAllVariants(shifuSessionId, function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants(shifuSessionId);Alternately, you can also use curl call to set a variant with this POST call to {host}:{port}/shifu/api/resetAllVariants/{shifuSessionId}curl -X GET  http://localhost:8080/shifu/api/resetAllVariants/{shifuSessionId}Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('@walmart/shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('@walmart/shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('@walmart/shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('@walmart/shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('@walmart/shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('@walmart/shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('@walmart/shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('@walmart/shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('@walmart/shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('@walmart/shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('@walmart/shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('@walmart/shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('@walmart/shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('@walmart/shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('@walmart/shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('@walmart/shifu);shifu.log.getLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('@walmart/shifu);shifu.log.resetLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/API Guide"
      },
    
      "mocking-native-ios-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Native iOS/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-native-ios-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments. The solution is being used by more than 70+ teams across different organizations within Walmart.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UICustomersThe following teams are using mocking service to mock their backend services during functional testing as well as during development.  Home  Easy Reorder  Product  Back To School  Reviews  NonConfig  Product  Store Finder  Thank You  Cart  Checkout  Lists  Sams Product  Sams Cart  Sams Checkout  Sams Join Now  Account  Customer Care  Smart Pay  Unified Login  Store Checkin  Store Ereceipt  Store Pharmacy Pay  Store Savings Catcher  Pharmacy Account  Search Tools  Tempo  TangoAnd more !!!",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-native-ios-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.js  The application needs to install npm modules from an internal repository. Add a file named .npmrc in the root of your project. Follow this npm guide to know more about .npmrc file.Setting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"@walmart/shifu\": \"^3.0.7\",   \"@walmart/shifu-magellan-nightwatch\": \"^2.0.2\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('@walmart/shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('@walmart/shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).       metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu',    metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-native-ios-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)  If inside of Walmart you need npm access to the internal nexus/npm repoHow Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"@walmart/shifu\": \"3.0.4\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});Why do I see No routes defined for this path ?Any undefined routes in Shifu will be responsed with a user friendly message No routes defined for this path.How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;    if(authorization) {       // do something    }    reply().code(204);  }}); How To Read Payload In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How to read url parameters in request ?To read the dynamic URL parameters in request with in the route, use request.paramsvar shifu = require('@walmart/shifu');shifu.route({  path: '/api/customer/{id}'  handler: function(req, reply) {    // would be \"123\" if the endpiont hit was \"/api/customer/123\"    var id = request.params.id;  }});How to add delay to response?A mocked response can also be delayed by some time specified by the user. You can simulate a delay (in ms) by passing delay as follows :shifu.route({  id: 'message',  label: 'Hello Variants',  path: '/message',  variantLabel: 'hello world',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply, {code: 202});  }}).variant({    id: 'variant with delay',    label: 'variant with delay',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {filePath: './message/GET/variant_with_delay.json', delay: 1000});    }  });How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate WayTo set custom headers, call header(name, value, options) on reply object, wherename is the header namevalue is the header valueoptions is an optional object with the following attributes            Attribute      Description                  append      if true, the value is appended to any existing header value using separator. Defaults to false.              separator      string used as separator when appending to an exiting value. Defaults to ','              override      if false, the header value is not set if an existing value present. Defaults to true              duplicate      if false, the header value is not modified if the provided value is already included. Does not apply when append is false or if the name is ‘set-cookie’. Defaults to true      shifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate WayTo set custom cookies, call state(name, value, options) on reply object, where name is the cookie namevalue is the cookie valueoptions is the server state options settings found hereshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?The Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web application running inside a browser which are loaded from a different domain than the API server. CORS headers are disabled by default. To enable, set cors to true, or to an object with the following options:            Option      Description                  origin      a string array of allowed origin servers Access-Control-Allow-Origin. Defaults to any origin [‘*’]              maxAge      number of seconds the browser should cache the CORS response (‘Access-Control-Max-Age’). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to 86400 (one day).              headers      string array of allowed headers Access-Control-Allow-Headers. Defaults to ['Authorization', 'Content-Type', 'If-None-Match'].              additionalHeaders      string array of additional headers to headers. Use this to keep the default headers in place.              methods      string array of allowed HTTP methods Access-Control-Allow-Methods. Defaults to ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']              additionalMethods      string array of additional methods to methods. Use this to keep the default methods in place              exposedHeaders      string array of exposed headers Access-Control-Expose-Headers. Defaults to ['WWW-Authenticate', 'Server-Authorization'              additionalExposedHeaders      a string array of additional headers to exposedHeaders. Use this to keep the default headers in place.              credentials      if true, allows user credentials to be sent Access-Control-Allow-Credentials. Defaults to false.      var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('@walmart/shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dCan I reset all variants for all the routes?Yes. Please refer resetAllVariants in API guide section.What Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read thisHow to send meta information for response ?Mocked responses can also have meta information that can be set in the response files itself. For example :{  \"setHeaders\": {    \"date\": \"Fri, 06 Jan 2017 03:33:22 GMT\",    \"content-type\": \"text/html; charset=UTF-8\",    \"transfer-encoding\": \"chunked\",    \"connection\": \"close\",    \"set-cookie\": [      \"__cfduid=d7502270409ade5544a5a60d0fbd7652a1483673602; expires=Sat, 06-Jan-18 03:33:22 GMT; path=/; domain=.typicode.com; HttpOnly\"    ],    \"x-powered-by\": \"Express\",    \"vary\": \"Accept-Encoding\",    \"access-control-allow-credentials\": \"true\",    \"cache-control\": \"public, max-age=14400\",    \"last-modified\": \"Thu, 05 Jan 2017 07:28:00 GMT\",    \"via\": \"1.1 vegur\",    \"cf-cache-status\": \"HIT\",    \"expires\": \"Fri, 06 Jan 2017 07:33:22 GMT\",    \"server\": \"cloudflare-nginx\",    \"cf-ray\": \"31cc1baee47b11fb-SJC\"  },  \"setCode\":201,  \"setPayload\": \"resources/mocked-data/message/GET/file_read_from_recorded_file.txt\",  \"setContentType\": \"text/plain; charset=utf-8\"}The above file is going to set the headers of the response from Shifu according to headers provided in setHeaders, code provided in setCode , contentType provided in setContentType and payload provided in setPayload. If setPayload is a path of the file intended to be responded with, then Shifu will look for the file and respond with the content of that file. If setPayload is JSON content, then Shifu will respond with JSON content.The above functionality makes sure that Shifu is able to handle all the file types when responding with recorded mocked data.In order to test different scenarios, you can add/delete/update header information in the setHeaders value. Or if you need to change the contentType of the response, you can simply replace value of setContentType.Please note that setContentType will take precedence over content-type header value. If setContentType is not provided then, HTTP will set the contentType of the file according to file type.How to add Shifu custom commands to Nightwatch?To add mock server custom commands to control the Shifu server in your end to end tests, add the following in nightwatch.json:\"custom_commands_path\": [    ...    \"./node_modules/shifu-magellan-nightwatch/commands\"  ],",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-native-ios-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js which can look something like this        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Gec Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Proxy  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      git clone git@gecgithub01.walmart.com:otto/shifu.git        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (2) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request against the development branch. The Looper build triggers a PR Verify build which runs the tests in CI environment (same steps as in (4) above).        Once the PR is reviewed , a team member merges the PR into the development branch.        When the development branch is merged to master, the Master Verify build is triggered and publishes a new version of the package to Walmart’s npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-native-ios-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Boilerplate with a web appThis boilerplate application is a web app built using Walmart’s public APIs to locate stores near a zip code. The responses are mocked using the Mock Server.      To run against live-service, use the following commad:    npm run start-live        To run against mock-service, use the following commad:    npm run start-mock  More details could be found in the README for the boilerplateParallel Sessions boilerplate/demoThis Boilerplates starts a mock server and demonstrates how the same rest end point could be used to return different datasets while running test cases in parallel. In this example, two test cases execute in parallel and access the Rest endpoint /api/homepage after setting two different variants on the same route using sessions.Test cases receives mocked html responses, one for jet.com homepage and other for walmart.com homepage.React Native boilerplateThis boilerplate demonstrates using mock-server for iOS test cases for react-native.More details could be found in the README for the boilerplate](https://gecgithub01.walmart.com/otto/boilerplate-nightwatch-react-native)Project ReferenceThis is an actual project for your reference from react-native ThankYou team that uses mock server to run test cases.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-mocking-native-ios-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Start Mock Server - start()  Stop Mock Server - stop()  Create Mocked Route - route()  Create Variant - variant()  Set variant - setMockVariant()  Reset all variants - resetAllVariants()          Without sessions      With sessions        Add global variants - addGlobalVariant()  Respond With File - respondWithFile()  Respond with mock variant - respondWithMockVariant()  Set Mock Id - setMockId()  Get Mock Id - getMockId()  Reset Mock Id - resetMockId()  Reset url count - resetURLCount()  Get url count - getURLCount()  Register session - registerSession()  Close session - closeSession()  Check session - checkSession()  Get sessions - getSessions()  Clear sessions - clearSessions()  Get project name - getProjectName()  Get port information - getPortInfo()  Add state - addState()  Get state - getState()  Clear state - clearState()  Enable Metrics - enableMetrics()  Check if metrics are enabled - isMetricsEnabled()  Dynamic transposition of JSON data - transposeData()  Kill process - killProcess()  Read contents of a file - readFile()  Read contents of a file - readFileSynchronously()  Read contents of JSON file - readJsonFile()  Write to file - writeFile()  Delete file - deleteFile()  Check if directory exists - checkDirectoryExists()  Check if file exists - checkFileExists()  Set Log level - setLogLevel()  Get Log level - getLogLevel()  Reset Log level - resetLogLevel()Start Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No              metricsDB      The database url where mock server posts usage metrics to  default: http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints      No      Examplevar shifu = require('@walmart/shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('@walmart/shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"universe\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Reset all variants - resetAllVariants()resetAllVariants can be used to reset all the variants for all routes for a given session id to default.shifu.resetAllVariants(shifuSessionId, callback) // with Shifu libraryor browser.resetAllVariants(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Session id for which all variants for all routes are to be set to default      No              callback      callback function to be called after resetAllVariants()      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});shifu.route({  id: 'hi',  path: '/hiWorld',  handler: function(request, reply) {    reply('Hi World');  }}).variant({  id: 'galaxy',  handler: function(request, reply) {    reply('Hi Galaxy');  }});Without sessionsWhen not using the sessions feature, you don’t need to send the shifuSessionId parameter. By default, resetAllVariants sets all the variants for all the routes to default for the default session.For the above routes, if the variant universe is set for the path helloWorld and variant galaxy is set for the path hiWorld, all the variants can be set to default for both these routes in this way:shifu.resetAllVariants(function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants();Alternately, you can also use curl call to set a variant with this POST call to `{host}:{port}/shifu/api/resetAllVariantscurl -X GET  http://localhost:8080/shifu/api/resetAllVariantsWith sessionsFor the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu library// shifuSessionId is a valid registered session with Shifushifu.resetAllVariants(shifuSessionId, function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants(shifuSessionId);Alternately, you can also use curl call to set a variant with this POST call to {host}:{port}/shifu/api/resetAllVariants/{shifuSessionId}curl -X GET  http://localhost:8080/shifu/api/resetAllVariants/{shifuSessionId}Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('@walmart/shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('@walmart/shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('@walmart/shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('@walmart/shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('@walmart/shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('@walmart/shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('@walmart/shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('@walmart/shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('@walmart/shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('@walmart/shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('@walmart/shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('@walmart/shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('@walmart/shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('@walmart/shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('@walmart/shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('@walmart/shifu);shifu.log.getLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('@walmart/shifu);shifu.log.resetLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/API Guide"
      },
    
      "documentation-mocking-native-android-java-introduction": {
        "title": "Introduction",
        "content": "SummaryMost apps rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.Shifu is a Java solution that enables you to quickly stub the API calls done by your app. During testing Shifu is deployed on the device/emulator enabling the app to point to the device localhost instead of calling live services. Pre-recorded responses are then returned for various endpoints from Shifu.Use CaseAs Shifu is deployed on the emulator/device there are no dependencies to a computer that might be on a secure hard to reach network. Shifu is also integrated directly with the tests and built into the test APK. Instrumentation testing frameworks like Espresso can be used. Shifu provides Espresso with an idling resource which further enhances your tests.  Provides an easy way to mock services  Execute same test cases against mock or live service  Easy to set up  Ability to use same JSON response file and change data dynamically for mocked response for various variants  No dependencies to extra APK or computer. Its a simple jar that works on both emulators and devices  Shifu can be built into the test APK by using androidTestCompile  Supports Record &amp; Replay  HTTPS Support: HTTPS support for all the urlsImpactHigher quality apps due to deterministic tests. As Shifu is easy to setup and use it also saves development time. Shifu supports record &amp; replay.Work FlowThe following is the work flow when mock server is used:  Identify REST endpoints that needs to be mocked  Gather or record mocked data for those REST endpoints  Setup an instrumentation test that initiates Shifu  Setup mocks with Shifu  Configure app to communicate with Shifu  Run your instrumentation test and the mocked data will be returned for mocked routes.Features List:            Features      Status                  Return multiple responses for same rest end point      Yes              Support for HTTP (for mocking)      Yes              Support for HTTPS (for mocking)      Yes              Ease of SetUp      Yes              Mock Java Services      Yes              Run tests manually against mock service      Yes              Read request (body, query parameters, etc) for mocked routes      Yes              Supports server states      Yes              Test Reuse      Yes              Dynamic Transposition of Mock Data (JSON)      Yes              Variants support for mocked REST APIs      Yes              Mocked data response from specific folder irrespective of Rest APIs      Yes              Support for record &amp; replay      Yes      CustomersThe following teams are using Shifu:      Android Core        Omnichannel  ",
        "url": "/documentation/Mocking/Native Android/Java/Introduction"
      },
    
      "documentation-mocking-native-android-java-getting-started": {
        "title": "Getting Started",
        "content": "Follow the instructions below if you want to see how Shifu can be setup.Set dependency in build.gradle:maven {    url 'http://gec-maven-nexus.walmart.com/nexus/content/repositories/thirdparty'}dependencies {    androidTestCompile 'com.walmart.otto:shifu:1.8.2'}Start Shifu:@Rulepublic ShifuRule shifuRule = new ShifuRule(new Shifu.Config(), InstrumentationRegistry.getTargetContext());Mock network requests:Mocking can be performed by record &amp; playback or by manual mapping:private void exampleOfManualMappingWithShifu() { //For a request url matching \"/example/example.*\" shifu will return ex.json that is located in the assets folder         shifu.mock(get(urlMatching(\"/example/example.*\")).willReturn(aResponse().withStatus(233).withBodyFile(\"ex.json\")));         //WithBodyFileInMockedDirectory can be used when setting Shifu.Config.mockedDirectory  so that full urls are not needed, only a path from the folder set in Config.mockedDirectory.          shifu.mock(post(urlMatching(\"/example/ex.jsp\")).willReturn(aResponse().withBodyFileInMockedDirectory(\"ex.json)));                      }Boilerplate ProjectPlease go here for an example project",
        "url": "/documentation/Mocking/Native Android/Java/Getting Started"
      },
    
      "documentation-mocking-native-android-java-faq": {
        "title": "FAQ",
        "content": "What Is Shifu?Shifu is a mocking tool for Android that is run on the emulator/device. It’s a library that is is setup and controlled from the Android tests. It has full support for http &amp; https and also supports record and playback.What Are The Benefits Of Shifu?  Easy to setup and use  No dependencies to extra APK or computer. Its a simple jar that works on both emulators and devices  Shifu can be built into the test APK by using androidTestCompile  Completely tailored for Android with a rich set of API:s  Full support for http &amp; https  Supports Record &amp; ReplayHow Do I Get Started?Please see getting startedWhere Can I Download a Boilerplate Project?Please download an example project hereHow Does Record &amp; Replay Work?Please see this page on record &amp; playbackWhat Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  Android API level 16How Can I Add Mock Server Dependency To My Android Project?Set dependency in build.gradle:maven {    url 'http://gec-maven-nexus.walmart.com/nexus/content/repositories/thirdparty'}dependencies {    androidTestCompile 'com.walmart.otto:shifu:1.8.2'}How Do I Start Shifu?Add the following code in your test class@Rulepublic ShifuRule shifuRule = new ShifuRule(new Shifu.Config(), InstrumentationRegistry.getTargetContext());How Do I Add A Mock?//For a request url matching \"/example/example.*\" shifu will return ex.json that is located in the assets folder        shifu.mock(get(urlMatching(\"/example/example.*\")).willReturn(aResponse().withStatus(233).withBodyFile(\"ex.json\")));How Do I Mock A Complete Directory?//WithBodyFileInMockedDirectory can be used when setting Shifu.Config.mockedDirectory so that full urls are not needed, only a path from the folder set in Config.mockedDirectory.         shifu.mock(post(urlMatching(\"/example/ex.jsp\")).willReturn(aResponse().withBodyFileInMockedDirectory(\"ex.json)));        ",
        "url": "/documentation/Mocking/Native Android/Java/FAQ"
      },
    
      "documentation-mocking-native-android-java-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code BaseAll contributions will be done on Github, including PR, review process etc.  Shifu-java code baseBranch OrganizationFor Shifu a PR should be opened for the master branchBugs reportingPlease file your ticket hereVersioningShifu follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.How to contact us  Ask questions in the slack channel: #testautomation",
        "url": "/documentation/Mocking/Native Android/Java/Contribution Guide"
      },
    
      "documentation-mocking-native-android-java-boilerplates": {
        "title": "Boilerplates",
        "content": "Android Espresso boilerplateTo see how Shifu can be used with your native Android tests please download an example project here",
        "url": "/documentation/Mocking/Native Android/Java/Boilerplates"
      },
    
      "documentation-mocking-native-android-java-api-guide": {
        "title": "API Guide",
        "content": "Please see available API’s here",
        "url": "/documentation/Mocking/Native Android/Java/API Guide"
      },
    
      "mocking-native-android-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Native Android/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-native-android-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments. The solution is being used by more than 70+ teams across different organizations within Walmart.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UICustomersThe following teams are using mocking service to mock their backend services during functional testing as well as during development.  Home  Easy Reorder  Product  Back To School  Reviews  NonConfig  Product  Store Finder  Thank You  Cart  Checkout  Lists  Sams Product  Sams Cart  Sams Checkout  Sams Join Now  Account  Customer Care  Smart Pay  Unified Login  Store Checkin  Store Ereceipt  Store Pharmacy Pay  Store Savings Catcher  Pharmacy Account  Search Tools  Tempo  TangoAnd more !!!",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-native-android-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.js  The application needs to install npm modules from an internal repository. Add a file named .npmrc in the root of your project. Follow this npm guide to know more about .npmrc file.Setting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"@walmart/shifu\": \"^3.0.7\",   \"@walmart/shifu-magellan-nightwatch\": \"^2.0.2\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('@walmart/shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('@walmart/shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).       metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu',    metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-native-android-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)  If inside of Walmart you need npm access to the internal nexus/npm repoHow Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"@walmart/shifu\": \"3.0.4\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});Why do I see No routes defined for this path ?Any undefined routes in Shifu will be responsed with a user friendly message No routes defined for this path.How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;    if(authorization) {       // do something    }    reply().code(204);  }}); How To Read Payload In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('@walmart/shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How to read url parameters in request ?To read the dynamic URL parameters in request with in the route, use request.paramsvar shifu = require('@walmart/shifu');shifu.route({  path: '/api/customer/{id}'  handler: function(req, reply) {    // would be \"123\" if the endpiont hit was \"/api/customer/123\"    var id = request.params.id;  }});How to add delay to response?A mocked response can also be delayed by some time specified by the user. You can simulate a delay (in ms) by passing delay as follows :shifu.route({  id: 'message',  label: 'Hello Variants',  path: '/message',  variantLabel: 'hello world',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply, {code: 202});  }}).variant({    id: 'variant with delay',    label: 'variant with delay',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {filePath: './message/GET/variant_with_delay.json', delay: 1000});    }  });How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate WayTo set custom headers, call header(name, value, options) on reply object, wherename is the header namevalue is the header valueoptions is an optional object with the following attributes            Attribute      Description                  append      if true, the value is appended to any existing header value using separator. Defaults to false.              separator      string used as separator when appending to an exiting value. Defaults to ','              override      if false, the header value is not set if an existing value present. Defaults to true              duplicate      if false, the header value is not modified if the provided value is already included. Does not apply when append is false or if the name is ‘set-cookie’. Defaults to true      shifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate WayTo set custom cookies, call state(name, value, options) on reply object, where name is the cookie namevalue is the cookie valueoptions is the server state options settings found hereshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?The Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web application running inside a browser which are loaded from a different domain than the API server. CORS headers are disabled by default. To enable, set cors to true, or to an object with the following options:            Option      Description                  origin      a string array of allowed origin servers Access-Control-Allow-Origin. Defaults to any origin [‘*’]              maxAge      number of seconds the browser should cache the CORS response (‘Access-Control-Max-Age’). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to 86400 (one day).              headers      string array of allowed headers Access-Control-Allow-Headers. Defaults to ['Authorization', 'Content-Type', 'If-None-Match'].              additionalHeaders      string array of additional headers to headers. Use this to keep the default headers in place.              methods      string array of allowed HTTP methods Access-Control-Allow-Methods. Defaults to ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']              additionalMethods      string array of additional methods to methods. Use this to keep the default methods in place              exposedHeaders      string array of exposed headers Access-Control-Expose-Headers. Defaults to ['WWW-Authenticate', 'Server-Authorization'              additionalExposedHeaders      a string array of additional headers to exposedHeaders. Use this to keep the default headers in place.              credentials      if true, allows user credentials to be sent Access-Control-Allow-Credentials. Defaults to false.      var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('@walmart/shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dCan I reset all variants for all the routes?Yes. Please refer resetAllVariants in API guide section.What Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('@walmart/shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read thisHow to send meta information for response ?Mocked responses can also have meta information that can be set in the response files itself. For example :{  \"setHeaders\": {    \"date\": \"Fri, 06 Jan 2017 03:33:22 GMT\",    \"content-type\": \"text/html; charset=UTF-8\",    \"transfer-encoding\": \"chunked\",    \"connection\": \"close\",    \"set-cookie\": [      \"__cfduid=d7502270409ade5544a5a60d0fbd7652a1483673602; expires=Sat, 06-Jan-18 03:33:22 GMT; path=/; domain=.typicode.com; HttpOnly\"    ],    \"x-powered-by\": \"Express\",    \"vary\": \"Accept-Encoding\",    \"access-control-allow-credentials\": \"true\",    \"cache-control\": \"public, max-age=14400\",    \"last-modified\": \"Thu, 05 Jan 2017 07:28:00 GMT\",    \"via\": \"1.1 vegur\",    \"cf-cache-status\": \"HIT\",    \"expires\": \"Fri, 06 Jan 2017 07:33:22 GMT\",    \"server\": \"cloudflare-nginx\",    \"cf-ray\": \"31cc1baee47b11fb-SJC\"  },  \"setCode\":201,  \"setPayload\": \"resources/mocked-data/message/GET/file_read_from_recorded_file.txt\",  \"setContentType\": \"text/plain; charset=utf-8\"}The above file is going to set the headers of the response from Shifu according to headers provided in setHeaders, code provided in setCode , contentType provided in setContentType and payload provided in setPayload. If setPayload is a path of the file intended to be responded with, then Shifu will look for the file and respond with the content of that file. If setPayload is JSON content, then Shifu will respond with JSON content.The above functionality makes sure that Shifu is able to handle all the file types when responding with recorded mocked data.In order to test different scenarios, you can add/delete/update header information in the setHeaders value. Or if you need to change the contentType of the response, you can simply replace value of setContentType.Please note that setContentType will take precedence over content-type header value. If setContentType is not provided then, HTTP will set the contentType of the file according to file type.How to add Shifu custom commands to Nightwatch?To add mock server custom commands to control the Shifu server in your end to end tests, add the following in nightwatch.json:\"custom_commands_path\": [    ...    \"./node_modules/shifu-magellan-nightwatch/commands\"  ],",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-native-android-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js which can look something like this        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Gec Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Proxy  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      git clone git@gecgithub01.walmart.com:otto/shifu.git        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (2) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request against the development branch. The Looper build triggers a PR Verify build which runs the tests in CI environment (same steps as in (4) above).        Once the PR is reviewed , a team member merges the PR into the development branch.        When the development branch is merged to master, the Master Verify build is triggered and publishes a new version of the package to Walmart’s npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-native-android-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Boilerplate with a web appThis boilerplate application is a web app built using Walmart’s public APIs to locate stores near a zip code. The responses are mocked using the Mock Server.      To run against live-service, use the following commad:    npm run start-live        To run against mock-service, use the following commad:    npm run start-mock  More details could be found in the README for the boilerplateParallel Sessions boilerplate/demoThis Boilerplates starts a mock server and demonstrates how the same rest end point could be used to return different datasets while running test cases in parallel. In this example, two test cases execute in parallel and access the Rest endpoint /api/homepage after setting two different variants on the same route using sessions.Test cases receives mocked html responses, one for jet.com homepage and other for walmart.com homepage.React Native boilerplateThis boilerplate demonstrates using mock-server for Android test cases for react-native.More details could be found in the README for the boilerplate](https://gecgithub01.walmart.com/otto/boilerplate-nightwatch-react-native)Project ReferenceThis is an actual project for your reference from react-native ThankYou team that uses mock server to run test cases.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-mocking-native-android-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Start Mock Server - start()  Stop Mock Server - stop()  Create Mocked Route - route()  Create Variant - variant()  Set variant - setMockVariant()  Reset all variants - resetAllVariants()          Without sessions      With sessions        Add global variants - addGlobalVariant()  Respond With File - respondWithFile()  Respond with mock variant - respondWithMockVariant()  Set Mock Id - setMockId()  Get Mock Id - getMockId()  Reset Mock Id - resetMockId()  Reset url count - resetURLCount()  Get url count - getURLCount()  Register session - registerSession()  Close session - closeSession()  Check session - checkSession()  Get sessions - getSessions()  Clear sessions - clearSessions()  Get project name - getProjectName()  Get port information - getPortInfo()  Add state - addState()  Get state - getState()  Clear state - clearState()  Enable Metrics - enableMetrics()  Check if metrics are enabled - isMetricsEnabled()  Dynamic transposition of JSON data - transposeData()  Kill process - killProcess()  Read contents of a file - readFile()  Read contents of a file - readFileSynchronously()  Read contents of JSON file - readJsonFile()  Write to file - writeFile()  Delete file - deleteFile()  Check if directory exists - checkDirectoryExists()  Check if file exists - checkFileExists()  Set Log level - setLogLevel()  Get Log level - getLogLevel()  Reset Log level - resetLogLevel()Start Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No              metricsDB      The database url where mock server posts usage metrics to  default: http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints      No      Examplevar shifu = require('@walmart/shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project',  metricsDB: 'http://kairos.prod.rapido.globalproducts.prod.walmart.com/api/v1/datapoints'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('@walmart/shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"universe\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Reset all variants - resetAllVariants()resetAllVariants can be used to reset all the variants for all routes for a given session id to default.shifu.resetAllVariants(shifuSessionId, callback) // with Shifu libraryor browser.resetAllVariants(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Session id for which all variants for all routes are to be set to default      No              callback      callback function to be called after resetAllVariants()      No      ExampleIf the routes are defined likevar shifu = require('@walmart/shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});shifu.route({  id: 'hi',  path: '/hiWorld',  handler: function(request, reply) {    reply('Hi World');  }}).variant({  id: 'galaxy',  handler: function(request, reply) {    reply('Hi Galaxy');  }});Without sessionsWhen not using the sessions feature, you don’t need to send the shifuSessionId parameter. By default, resetAllVariants sets all the variants for all the routes to default for the default session.For the above routes, if the variant universe is set for the path helloWorld and variant galaxy is set for the path hiWorld, all the variants can be set to default for both these routes in this way:shifu.resetAllVariants(function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants();Alternately, you can also use curl call to set a variant with this POST call to `{host}:{port}/shifu/api/resetAllVariantscurl -X GET  http://localhost:8080/shifu/api/resetAllVariantsWith sessionsFor the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu library// shifuSessionId is a valid registered session with Shifushifu.resetAllVariants(shifuSessionId, function (err) {    if (err) {        console.log('Error in resetting all variants:' + err);    } else {        console.log('Successfully reset variants');    }});or // When using Magellanbrowser.resetAllVariants(shifuSessionId);Alternately, you can also use curl call to set a variant with this POST call to {host}:{port}/shifu/api/resetAllVariants/{shifuSessionId}curl -X GET  http://localhost:8080/shifu/api/resetAllVariants/{shifuSessionId}Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('@walmart/shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('@walmart/shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('@walmart/shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('@walmart/shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('@walmart/shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('@walmart/shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('@walmart/shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('@walmart/shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('@walmart/shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('@walmart/shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('@walmart/shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('@walmart/shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('@walmart/shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('@walmart/shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('@walmart/shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('@walmart/shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('@walmart/shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('@walmart/shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('@walmart/shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('@walmart/shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('@walmart/shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('@walmart/shifu);shifu.log.getLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('@walmart/shifu);shifu.log.resetLogLevel();orvar Logger = require('@walmart/shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-rweb-javascript-training-guide": {
        "title": "Training Guide",
        "content": "30 minSetupCovered topicsPrerequisitesSetupRun demo tests locallyStart50 minrWeb TestingCovered topicsPrerequisitesBuilt-in browser testingRemote browser testingStart50 minMagellanCovered topicsMagellan introductionMagellan usageConfigure test profilesStart50 minTests FrameworkCovered topicsTests framework structurePage Object propertiesStart",
        "url": "/Functional Testing/rWeb/JAVASCRIPT/Training Guide"
      },
    
      "documentation-functional-testing-rweb-javascript-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional JS Test Development Kit (TDK) is a set of tools for making cross-browser end-to-end testing fast, user-friendly, and valuable at scale, across large teams, without those annoying false positives.The following tools are part of the functional JS TDK:      Magellan - Magellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Nightwatch-Extra - Nightwatch is a friendly NodeJS-based wrapper for Selenium, allowing developers to author tests in a way that’s easy to learn and quick to iterate on. The Nightwatch-Extra adapter is the first of many adapters to come for bringing other webdriver wrappers into the TestArmada ecosystem.        Executor - Executor acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).        Reporter - Magellan can give you various test reports if configured with a proper reporter. There are already several reporters available in Testarmada to grab, however the simple API Testarmada exposes also allows to create a customized reporter in an easy way.        Admiral - Like a tree falling in the woods, a test report that nobody reads doesn’t make a sound. Admiral is a beautiful dashboard that makes it easy to check the latest cross-browser test results, and to spot trends and sources of failures.  Use CaseBuilt for Walmart ScaleBuilt at WalmartLabs to drive quality for the world’s largest retailer, TestArmada is battle-tested, enterprise-grade, and ready to take on end-to-end testing for your site.Results You Can TrustTestArmada won’t waste your team’s time or erode its trust with annoying false-positives. When failures occur, TestArmada intelligently retries the tests to smooth over common sources of “test flake”.More Signal, Less NoiseThe functional JS TDK tells you everything you need to know, and nothing you don’t. Notifications occur in real-time when tests fail, and a beautiful dashboard always shows the latest status for each suite.ImpactWith the functional JS TDK, WalmartLabs has made end-to-end testing part of the shared culture between dev &amp; QA. Both organizations collaborate to ensure quality at all levels development, staging, and production.Feature ListThe functional JS TDK supports:      Frameworks - Nightwatch &amp; Mocha        Reporters - xunit, json &amp; mongo db        Clouds - Saucelabs &amp; Testobject  CustomersThe following teams are using the functional JS TDK:  Home  Easy Reorder  Product  Back To School  Reviews  NonConfig  Product  Store Finder  Thank You  Cart  Checkout  Lists  Account  Customer Care  Smart Pay  Unified Login  Pharmacy Account  Search Tools  Tempo  Tango",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Introduction"
      },
    
      "documentation-functional-testing-rweb-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre RequisiteThe functional JS TDK requires minimum node@4 and npm@2.Getting started with the functional JS TDKRun the following commands in your favorite terminal to see the functional JS TDK in action:git clone git@github.com:TestArmada/boilerplate-nightwatch.gitnpm installnpm run test:desktopYou should have seen the test runner magellan open up Chrome and run one test through it.Next, try the following command. It demonstrates TestArmada’s ability to drive multiple browsers in parallel, and aggregate the results:npm run testYou should have seen 2 Chrome windows open at once (probably stacked on top of each other) and the results of all two tests aggregated on the console.Via Command Line ArgumentsMagellan which is part of the functional JS TDK is designed for running tests in massive scale, which means you’ve been granted the full control of the scalability. There are two ways to tell magellan how you want to scale your tests.All command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command in your favorite bash./node_modules/.bin/magellan --helpFollowing is an example telling magellan to run tests with 30 workers, 5 retry attempts per failed test and bail whole suite if any failure is met../node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5 --bail_fastConfigure test profileMagellan passes down test profile information, like which browser or test environment your test runs in, to its executor(s). Usually this is done by setting up a specific argument in magellan command, such as./node_modules/.bin/magellan --local_browser chromeVia –profile command line argumentMagellan can retrieve test profile information from an URL. This gives you the convenience of managing your test environments and sharing your configuration management in a more standard way. Furthermore, by putting test profiles in to a file, you can add more information into your test profile, such as screen resolution, orientation or device information for you app test.The hosted test profile file needs to follow the format of{  \"profiles\": {    \"microsoftedge\": [{      \"browser\": \"microsoftedge_14_Windows_10_Desktop\",      \"resolution\": \"1280x1024\",      \"executor\": \"sauce\"    }],}Magellan can read and resolve the hosted profile by following command../node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via./node_modules/.bin/magellan --profile http://some.host#microsoftedge,googlechrome59,firefox57Or, as a better way to handle multiple test profiles as a batch, you can put multiple test profiles into one collection, such as{  \"profiles\": {    \"tier-one-browsers\": [{        \"browser\": \"microsoftedge_14_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"chrome_latest_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"iphone_10_0_iOS_iPhone_7_Simulator\",        \"orientation\": \"portrait\",        \"appium\": {          \"app\": \"sauce-storage:my_app.zip\",          \"appiumVersion\": \"1.6.4\",          \"automationName\": \"xcuitest\",          \"sendKeyStrategy\": \"setValue\",          \"waitForAppScript\": \"true\"        }      }    ]  }}Then simply call magellan with./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json supports the same test profile format as the hosted test profile file. Put the above js code snippet in magellan.json and it is ready to use via./node_modules/.bin/magellan --profile tier-one-browsersEnable executorYou need to tell magellan which executor it should use for a test profile. By default, if no executor is specified in profile, magellan is going to run it with magellan-saucelabs-executor if it is configured in magellan.json or magellan will error out.At least one executor has to be enabled in magellan.json. Please follow these steps to enable executor:  Install necessary executor via npm install    npm install testarmada-magellan-saucelabs-executor --save        Add following code in your magellan.json      \"executors\": [ \"magellan-saucelabs-executor\",  ],      Run test with executor(s)Magellan allows to run tests with one or more executors at the same time. Typically this is done by passing a specific command line argument to magellan. For example, to enable magellan-local-executor for all the tests, this command line argument is required# to run in Chrome--local_browser chrome or# to run in both Chrome and Firefox--local_browsers chrome, firefox Here is another example to enable both magellan-local-executor and magellan-saucelabs-executor for your test:# to run in local Chrome and Safari 10 on Saucelabs--local_browser chrome --sauce_browser safari_10_OS_X_10_11_Desktop Using ReporterReporter extends magellan’s reporting mechanism and increases the report format that magellan supports. With reporters magellan can now create test report in various formats for different audiences.Enable reporter(s)To enable multiple reporters, simply add them in magellan.json  \"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ]Please note: By default, magellan prints logs to terminal console while running. This default behavior won’t change and cannot be changed no matter how many other reporters are enabled.Create tests with Nightwatch-extraNightwatch-extra supports everything that nightwatchjs supports. Please refer to nightwatchjs’ developer guide for the basic usage of nightwatchjs.Extend the base-test-class.jsNightwatch-extra’s base-test-class.js passes certain information, such as selenium session information and test result, back to magellan. We highly recommend all your tests extend it.const Test = require(\"testarmada-nightwatch-extra/lib/base-test-class\");module.exports = new Test({  \"Load goole page\": function (client) {    client.url(\"http://www.google.com\");  }});Enable nightwatch-extra commandTo use nightwatch-extra’s command API, you need to add its path to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\"  ],A typical flow of how nightwatch-extra’s command works is  Get all information, like selector, values, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element via do().All commands of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Enable nightwatch-extra assertionTo use nightwatch-extra’s assertion API, you need to add its path to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\"  ],A typical flow of how nightwatch-extra’s assertion works is  Get all information, like selector, expectedValue, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element and assert via assert().All assertions of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Page ObjectNightwatch-extra is fully compatible with nightwatchjs’ page object pattern. You can access nightwatch-extra’s API or your customized API in page object command via  createNewCreditCard: function() {    const selectors = this.elements;    return this      .clickEl(selectors.addCreditCardButton.selector)      .setElValue(selectors.firstName.selector, \"testarmada\");  },All nightwatchjs’ APIs are accessible and chainable with nightwatch-extra’s API or your customized API via  selectPayByCash: function() {    this      .clickMobileEl(\"accessibility id\", selectors.morePaymentOptions.selector)      .swipeMobileElTo(\"xpath\", selectors.visaCheckout.selector, 0, -50)      .api.pause(3000)      .clickMobileEl(\"xpath\", selectors.payWithCash.selector);    return this;  }",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Getting Started"
      },
    
      "documentation-functional-testing-rweb-javascript-faq": {
        "title": "FAQ",
        "content": "I’m having npm install failure, what should I do?Please make sure that you’re using compatible node and npm. Check versions by node -v and npm -vTo install Node and NPM, click here. NPM is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer.Which magellan command should I use to launch my test?Please read magellan help by ./node_modules/.bin/magellan –help first. If you cannot find what you want there, or if you’re still not sure, please reach us in slack channel lised belowHow should I run my test in different browsers?If you want to test locally, Firefox and Chrome would be supported by default no matter which OS you’re using. To run test in Safari, you need to follow this article. To run in IE serie, you need a Windows. Or, just simply invoke your test on saucelabs.How should I run my test in mobile browser?Please use Saucelabs.How should I debug my test?Right now we don’t have fancy feature like block current execution –&gt; do some variable watch –&gt; resume your test. However, you can add a .pause() command before the command you want to debug, run your test and check selector from either developer tool or firebug from browser. Another option is adding tons of console.log() in your test.Why my test passes in one browser but fails in another one?There are couple of things can impact the test results. Page rendering speed, css selector compatibility, viewport size or even the way element’s being rendered. However in most cases the descrepancy is because we’re not really simulating user behaviors in the test. For instance, please make sure your code is not clicking on an element that is not in the viewport.Can I have this feature?If you are asking for a customized command, please check if similar command exists in testarmada.io#API and nightwatch first. Or, if you are asking for a feature like data tools, or any other stuff that you think is useful, please ping us in slack channel.What to do if I cannot download and install some certain node packagesIf it’s Walmart internal npm packages are the problem ones, please follow the steps listed here.Bentonville: if you cannot reach a certain public npm packages because of the proxy issue. You can either use the sample project setup on looper to get your tests run on CI, or ask people to share their node packages via Box.Cannot check in your changesPlease make sure you have write access for the repo, and you need to set the SSH key right. To check for exiting SSH Keys, click here.  Generate a new SSH key and adding it to the ssh-agent, click here.  Add a new SSH key to your GitHub account, click here.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/FAQ"
      },
    
      "documentation-functional-testing-rweb-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.      Magellan code base        Nightwatch-Extra code base  Bugs reportingPlease file the issue in the github projects above. Please ensure your issue has not been reported earlier.VersioningThe functional TDK follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.Customize commandWe provide a base-command.js for inheritance to implement your own command for browser test. To implement a command for browser usage, you need to  Inherit your command from the base-command.js.  Implement method do() and command()            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              command(…, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with an optional callback which will be called when the command successfully finishes.        Add the path of your new command to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\",    \"./node_modules/testarmada-nightwatch-extra/lib/commands/mobile\",    \"./lib/custom_commands\"  ],Customize assertionWe provide a base-assertion.js for inheritance to implement your own assertion for browser test. To implement an assertion for browser test, you need to  Inherit your assertion from the base-assertion.js.  Implement method do(), assert() and command().            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              assert(actual, expected)      Called by base assertion if element exists and is visible, you can do you own assertion in this method.      actual is the actual value returned by injectedJsCommand() method, expected is the expected value passed in command() method              command(selector, expected, …, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with a selector, an expected value and an optional callback which will be called when the assertion successfully finishes.        Add the path to your new assertion to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\",    \"./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile\",    \"./lib/custom_assertions\"  ],Contribute to reporterCreate a reporterA reporter must implement following methods.            Method      Purpose                  initialize()      initialize current reporter instance              listenTo(testRun, test, source)      listen to magellan’s test run              _handleMessage(testRun, test, msg)      will be called when magellan emits certain events              flush()      will be called when magellan finishes      Please note: _handleMessage() will be called per test. Please handle the error properly if it happens in one of the _handleMessage() so all your following _handleMessage() and flush() don’t error out.Enable your reporterTo enable multiple reporters, simply add them in magellan.json\"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ],",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-functional-testing-rweb-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Nightwatch archetypeThe easiest way to try out the functional JS TDK is to use the below archetype project. It will help you setup the necessary file structure in your project and generate a mocked test for you to execute. Please go here for more information.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-functional-testing-rweb-javascript-api-guide": {
        "title": "API Guide",
        "content": "Nightwatch-Extra API:sCommands.getEl()description:Returns a html elementSyntax:.getEl(selector, callback/*optional*/);Parameters:selector : css selector to identify the html element.callback : callback which includes the element information.Usage:.getEl(\".dropdown-link .user-name\", function(element){  console.log(element); // will print out {'ELEMENT': 1}});.getEls()description:Returns html elementsSyntax:.getEls(selector, callback/*optional*/);Parameters:selector : css selector to identify the html elements.callback : callback which includes the elements information.Usage:.getEls(\".dropdown-link .user-name\", function(element){  console.log(element);  // will print out [{'ELEMENT': 1}, .....]});.clickEl()description:Click a html elementSyntax:.clickEl(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : optional callback to be called when the command finishes.Usage:.clickEl(\"#submit\");.clickAutomationEl()description:Click an html element which has html attribute [data-automation-id].Syntax:.clickAutomationEl(id, callback/*optional*/);Parameters:id : value of data-automation-id attribute.callback : optional callback to be called when the command finishes.Usage:.clickAutomationEl(\"placeOrder\"); // equals to .clickEl('[data-automation-id=\"placeOrder\"]');.getElValue()description:Returns the textual value of a html element.Syntax:.getElValue(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : callback which includes the value of the element.Usage:.getElValue(\".user-profile\", function(profile){ });.setElValue()description:Sets value to a html element.Syntax:.setElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setElValue(\"#username\", \"fake@login.com\");.setMaskedElValue()description:Sets value to a masked html element like credit card number or phone number.Syntax:.setMaskedElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setMaskedElValue(\".phone-number\", \"123456789\");.moveToEl()description:Moves cursor to a html elementSyntax:.moveToEl(selector, xoffset, yoffset, callback/*optional*/);Parameters:selector : css selector to the html element.xoffset : x offset to move to, relative to the top-left corner of the element.yoffset : y offset to move to, relative to the top-left corner of the element.callback : optional callback to be called when the command finishes.Usage:.moveToEl(\".checkout\", 10, 10);.takeElScreenshot()description:Takes screenshot for a html element and save it to fileSyntax:.takeElScreenshot(selector, filename, callback/*optional*/);Parameters:selector : css selector to the html element.filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeElScreenshot(\".phone-number\", \"phone-number\");.takeScreenhot()description:Takes screenshot for the page.Syntax:.takeScreenhot(filename, callback/*optional*/);Parameters:filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeScreenhot(\"home-page\");.assert.elContainsText()description:Asserts if current element contains a given textSyntax:.assert.elContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elContainsText(\".username\", \"testarmada\");.assert.elNotContainsText()description:Asserts if current element doesn’t contain a given textSyntax:.assert.elNotContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elNotContainsText(\".username\", \"testarmada\");.assert.selectorHasLength()description:Asserts if current selector returns given amount of elementsSyntax:.assert.selectorHasLength(selector, value);Parameters:selector : css selector to the html element.value : numeric value to assert.Usage:.assert.selectorHasLength(\".username\", 1);.assert.elValueContains()description:Asserts if current element contains the given valueSyntax:.assert.elValueContains(selector, value);Parameters:selector : css selector to the html element.value : textual value to assert.Usage:.assert.elValueContains(\".username\", \"Leo\");.assert.elLengthGreaterThan()description:Asserts if the length of an element’s attribute is greater than a numberSyntax:.assert.elLengthGreaterThan(selector, using, value);Parameters:selector : css selector to the html element.using : element attribute, can be chosen from [“value”, “text”, “html”, “length”].value : numeric value to assert.Usage:.assert.elLengthGreaterThan(\".username\", \"text\", 1);Nightwatch API:sFor Nightwatch API:s please go here",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-native-ios-javascript-training-guide": {
        "title": "Training Guide",
        "content": "30 minSetupCovered topicsSetup iOS app test on local machineSetup iOS app test on Sauce LabsStart50 minTests FrameworkCovered topicsExecution commandsUnderstand tests framework structureStart50 miniOS AutomationCovered topicsDesired CapabilitiesNative app locatorsStart20 minTrouble ShootingCovered topicsTrouble shooting tipsStart",
        "url": "/Functional Testing/Native iOS/JAVASCRIPT/Training Guide"
      },
    
      "documentation-functional-testing-native-ios-javascript-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional JS Test Development Kit (TDK) is a set of tools for making iOS apps written in Objective-C, Swift &amp; React Native apps end-to-end testing fast, user-friendly, and valuable at scale, across large teams, without those annoying false positives. Both simulators and real devices are supported.The following tools are part of the functional JS TDK:      Magellan - Magellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Nightwatch-Extra - Nightwatch is a friendly NodeJS-based wrapper for Selenium, allowing developers to author tests in a way that’s easy to learn and quick to iterate on. The Nightwatch-Extra adapter is the first of many adapters to come for bringing other webdriver wrappers into the TestArmada ecosystem.        Executor - Executor acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).        Reporter - Magellan can give you various test reports if configured with a proper reporter. There are already several reporters available in Testarmada to grab, however the simple API Testarmada exposes also allows to create a customized reporter in an easy way.        Admiral - Like a tree falling in the woods, a test report that nobody reads doesn’t make a sound. Admiral is a beautiful dashboard that makes it easy to check the latest cross-browser test results, and to spot trends and sources of failures.  Use CaseBuilt for Walmart ScaleBuilt at WalmartLabs to drive quality for the world’s largest retailer, TestArmada is battle-tested, enterprise-grade, and ready to take on end-to-end testing for your site.Results You Can TrustTestArmada won’t waste your team’s time or erode its trust with annoying false-positives. When failures occur, TestArmada intelligently retries the tests to smooth over common sources of “test flake”.More Signal, Less NoiseThe functional JS TDK tells you everything you need to know, and nothing you don’t. Notifications occur in real-time when tests fail, and a beautiful dashboard always shows the latest status for each suite.ImpactWith the functional JS TDK, WalmartLabs has made end-to-end testing part of the shared culture between dev &amp; QA. Both organizations collaborate to ensure quality at all levels development, staging, and production.Feature ListThe functional JS TDK supports:      Frameworks - Nightwatch &amp; Mocha        Reporters - xunit, json &amp; mongo db        Clouds - Saucelabs &amp; Testobject  CustomersThe following teams are using the functional iOS JS TDK:      Checkout RN        Store        Account Mobile        Omnichannel Mobile  ",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Introduction"
      },
    
      "documentation-functional-testing-native-ios-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre RequisiteThe functional JS TDK requires minimum node@4 and npm@3 for device testing.Getting started with the functional JS TDKTo proceed with native iOS app test, you also need latest Xcode and it’s command line tools. When you have Xcode setup, please make sure your desired iOS simulator is installed as well.SetupPlease follow the archetype project otto-archetype-app to have your first native app test automation project run in your local.Then please follow the boilerplate project boilerplate-nightwatch-mobile for more examples and advanced usage.Via Command Line ArgumentsMagellan which is part of the functional JS TDK is designed for running tests in massive scale, which means you’ve been granted the full control of the scalability. There are two ways to tell magellan how you want to scale your tests.All command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command in your favorite bash./node_modules/.bin/magellan --helpFollowing is an example telling magellan to run tests with 30 workers, 5 retry attempts per failed test and bail whole suite if any failure is met../node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5 --bail_fastConfigure test profileMagellan passes down test profile information, like which browser or test environment your test runs in, to its executor(s). Usually this is done by setting up a specific argument in magellan command, such as./node_modules/.bin/magellan --local_browser chromeVia –profile command line argumentMagellan can retrieve test profile information from an URL. This gives you the convenience of managing your test environments and sharing your configuration management in a more standard way. Furthermore, by putting test profiles in to a file, you can add more information into your test profile, such as screen resolution, orientation or device information for you app test.The hosted test profile file needs to follow the format of{  \"profiles\": {    \"microsoftedge\": [{      \"browser\": \"microsoftedge_14_Windows_10_Desktop\",      \"resolution\": \"1280x1024\",      \"executor\": \"sauce\"    }],}Magellan can read and resolve the hosted profile by following command../node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via./node_modules/.bin/magellan --profile http://some.host#microsoftedge,googlechrome59,firefox57Or, as a better way to handle multiple test profiles as a batch, you can put multiple test profiles into one collection, such as{  \"profiles\": {    \"tier-one-browsers\": [{        \"browser\": \"microsoftedge_14_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"chrome_latest_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"iphone_10_0_iOS_iPhone_7_Simulator\",        \"orientation\": \"portrait\",        \"appium\": {          \"app\": \"sauce-storage:my_app.zip\",          \"appiumVersion\": \"1.6.4\",          \"automationName\": \"xcuitest\",          \"sendKeyStrategy\": \"setValue\",          \"waitForAppScript\": \"true\"        }      }    ]  }}Then simply call magellan with./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json supports the same test profile format as the hosted test profile file. Put the above js code snippet in magellan.json and it is ready to use via./node_modules/.bin/magellan --profile tier-one-browsersEnable executorYou need to tell magellan which executor it should use for a test profile. By default, if no executor is specified in profile, magellan is going to run it with magellan-saucelabs-executor if it is configured in magellan.json or magellan will error out.At least one executor has to be enabled in magellan.json. Please follow these steps to enable executor:  Install necessary executor via npm install    npm install testarmada-magellan-saucelabs-executor --save        Add following code in your magellan.json      \"executors\": [ \"magellan-saucelabs-executor\",  ],      Run test with executor(s)Magellan allows to run tests with one or more executors at the same time. Typically this is done by passing a specific command line argument to magellan. For example, to enable magellan-local-executor for all the tests, this command line argument is required# to run in Chrome--local_browser chrome or# to run in both Chrome and Firefox--local_browsers chrome, firefox Here is another example to enable both magellan-local-executor and magellan-saucelabs-executor for your test:# to run in local Chrome and Safari 10 on Saucelabs--local_browser chrome --sauce_browser safari_10_OS_X_10_11_Desktop Using ReporterReporter extends magellan’s reporting mechanism and increases the report format that magellan supports. With reporters magellan can now create test report in various formats for different audiences.Enable reporter(s)To enable multiple reporters, simply add them in magellan.json  \"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ]Please note: By default, magellan prints logs to terminal console while running. This default behavior won’t change and cannot be changed no matter how many other reporters are enabled.Create test with Nightwatch-extraNightwatch-extra supports everything that nightwatchjs supports. Please refer to nightwatchjs’ developer guide for the basic usage of nightwatchjs.Extend the base-test-class.jsNightwatch-extra’s base-test-class.js passes certain information, such as selenium session information and test result, back to magellan. We highly recommend all your tests extend it.const Test = require(\"testarmada-nightwatch-extra/lib/base-test-class\");module.exports = new Test({  \"Load goole page\": function (client) {    client.url(\"http://www.google.com\");  }});Enable nightwatch-extra commandTo use nightwatch-extra’s command API, you need to add its path to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\"  ],A typical flow of how nightwatch-extra’s command works is  Get all information, like selector, values, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element via do().All commands of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Enable nightwatch-extra assertionTo use nightwatch-extra’s assertion API, you need to add its path to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\"  ],A typical flow of how nightwatch-extra’s assertion works is  Get all information, like selector, expectedValue, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element and assert via assert().All assertions of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Page ObjectNightwatch-extra is fully compatible with nightwatchjs’ page object pattern. You can access nightwatch-extra’s API or your customized API in page object command via  createNewCreditCard: function() {    const selectors = this.elements;    return this      .clickEl(selectors.addCreditCardButton.selector)      .setElValue(selectors.firstName.selector, \"testarmada\");  },All nightwatchjs’ APIs are accessible and chainable with nightwatch-extra’s API or your customized API via  selectPayByCash: function() {    this      .clickMobileEl(\"accessibility id\", selectors.morePaymentOptions.selector)      .swipeMobileElTo(\"xpath\", selectors.visaCheckout.selector, 0, -50)      .api.pause(3000)      .clickMobileEl(\"xpath\", selectors.payWithCash.selector);    return this;  }",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Getting Started"
      },
    
      "documentation-functional-testing-native-ios-javascript-faq": {
        "title": "FAQ",
        "content": "I’m having npm install failure, what should I do?Please make sure that you’re using compatible node and npm. Check versions by node -v and npm -vTo install Node and NPM, click here. NPM is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer.Which magellan command should I use to launch my test?Please read magellan help by ./node_modules/.bin/magellan –help first. If you cannot find what you want there, or if you’re still not sure, please reach us in slack channel lised belowHow should I run my test in different devices?If you want to test locally, please make sure corresponding dev tools are installed correctly. Also for android please make sure a proper AVD is set.How should I debug my test?Please use appium desktop app to get your element or coordinates.Can I have this feature?If you are asking for a customized command, please check if similar command exists in testarmada.io#API and nightwatch first. Or, if you are asking for a feature like data tools, or any other stuff that you think is useful, please ping us in slack channel.What to do if I cannot download and install some certain node packagesIf it’s Walmart internal npm packages are the problem ones, please follow the steps listed here.Bentonville: if you cannot reach a certain public npm packages because of the proxy issue. You can either use the sample project setup on looper to get your tests run on CI, or ask people to share their node packages via Box.Cannot check in your changesPlease make sure you have write access for the repo, and you need to set the SSH key right. To check for exiting SSH Keys, click here.  Generate a new SSH key and adding it to the ssh-agent, click here.  Add a new SSH key to your GitHub account, click here.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/FAQ"
      },
    
      "documentation-functional-testing-native-ios-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.      Magellan code base        Nightwatch-Extra code base  Bugs reportingPlease file the issue in the github projects above. Please ensure your issue has not been reported earlier.VersioningThe functional TDK follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.Customize commandWe provide a base-command.js for inheritance to implement your own command for browser test. To implement a command for browser usage, you need to  Inherit your command from the base-command.js.  Implement method do() and command()            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              command(…, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with an optional callback which will be called when the command successfully finishes.        Add the path of your new command to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\",    \"./node_modules/testarmada-nightwatch-extra/lib/commands/mobile\",    \"./lib/custom_commands\"  ],Customize assertionWe provide a base-assertion.js for inheritance to implement your own assertion for browser test. To implement an assertion for browser test, you need to  Inherit your assertion from the base-assertion.js.  Implement method do(), assert() and command().            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              assert(actual, expected)      Called by base assertion if element exists and is visible, you can do you own assertion in this method.      actual is the actual value returned by injectedJsCommand() method, expected is the expected value passed in command() method              command(selector, expected, …, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with a selector, an expected value and an optional callback which will be called when the assertion successfully finishes.        Add the path to your new assertion to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\",    \"./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile\",    \"./lib/custom_assertions\"  ],Contribute to reporterCreate a reporterA reporter must implement following methods.            Method      Purpose                  initialize()      initialize current reporter instance              listenTo(testRun, test, source)      listen to magellan’s test run              _handleMessage(testRun, test, msg)      will be called when magellan emits certain events              flush()      will be called when magellan finishes      Please note: _handleMessage() will be called per test. Please handle the error properly if it happens in one of the _handleMessage() so all your following _handleMessage() and flush() don’t error out.Enable your reporterTo enable multiple reporters, simply add them in magellan.json\"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ],",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-functional-testing-native-ios-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Nightwatch Mobile boilerplateTo learn more about the functional JS TDK and to see an example project of how it can be used please go here",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-functional-testing-native-ios-javascript-api-guide": {
        "title": "API Guide",
        "content": "Nightwatch-Extra API:sCommands.getEl()description:Returns a html elementSyntax:.getEl(selector, callback/*optional*/);Parameters:selector : css selector to identify the html element.callback : callback which includes the element information.Usage:.getEl(\".dropdown-link .user-name\", function(element){  console.log(element); // will print out {'ELEMENT': 1}});.getEls()description:Returns html elementsSyntax:.getEls(selector, callback/*optional*/);Parameters:selector : css selector to identify the html elements.callback : callback which includes the elements information.Usage:.getEls(\".dropdown-link .user-name\", function(element){  console.log(element);  // will print out [{'ELEMENT': 1}, .....]});.clickEl()description:Click a html elementSyntax:.clickEl(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : optional callback to be called when the command finishes.Usage:.clickEl(\"#submit\");.clickAutomationEl()description:Click an html element which has html attribute [data-automation-id].Syntax:.clickAutomationEl(id, callback/*optional*/);Parameters:id : value of data-automation-id attribute.callback : optional callback to be called when the command finishes.Usage:.clickAutomationEl(\"placeOrder\"); // equals to .clickEl('[data-automation-id=\"placeOrder\"]');.getElValue()description:Returns the textual value of a html element.Syntax:.getElValue(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : callback which includes the value of the element.Usage:.getElValue(\".user-profile\", function(profile){ });.setElValue()description:Sets value to a html element.Syntax:.setElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setElValue(\"#username\", \"fake@login.com\");.setMaskedElValue()description:Sets value to a masked html element like credit card number or phone number.Syntax:.setMaskedElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setMaskedElValue(\".phone-number\", \"123456789\");.moveToEl()description:Moves cursor to a html elementSyntax:.moveToEl(selector, xoffset, yoffset, callback/*optional*/);Parameters:selector : css selector to the html element.xoffset : x offset to move to, relative to the top-left corner of the element.yoffset : y offset to move to, relative to the top-left corner of the element.callback : optional callback to be called when the command finishes.Usage:.moveToEl(\".checkout\", 10, 10);.takeElScreenshot()description:Takes screenshot for a html element and save it to fileSyntax:.takeElScreenshot(selector, filename, callback/*optional*/);Parameters:selector : css selector to the html element.filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeElScreenshot(\".phone-number\", \"phone-number\");.takeScreenhot()description:Takes screenshot for the page.Syntax:.takeScreenhot(filename, callback/*optional*/);Parameters:filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeScreenhot(\"home-page\");.assert.elContainsText()description:Asserts if current element contains a given textSyntax:.assert.elContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elContainsText(\".username\", \"testarmada\");.assert.elNotContainsText()description:Asserts if current element doesn’t contain a given textSyntax:.assert.elNotContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elNotContainsText(\".username\", \"testarmada\");.assert.selectorHasLength()description:Asserts if current selector returns given amount of elementsSyntax:.assert.selectorHasLength(selector, value);Parameters:selector : css selector to the html element.value : numeric value to assert.Usage:.assert.selectorHasLength(\".username\", 1);.assert.elValueContains()description:Asserts if current element contains the given valueSyntax:.assert.elValueContains(selector, value);Parameters:selector : css selector to the html element.value : textual value to assert.Usage:.assert.elValueContains(\".username\", \"Leo\");.assert.elLengthGreaterThan()description:Asserts if the length of an element’s attribute is greater than a numberSyntax:.assert.elLengthGreaterThan(selector, using, value);Parameters:selector : css selector to the html element.using : element attribute, can be chosen from [“value”, “text”, “html”, “length”].value : numeric value to assert.Usage:.assert.elLengthGreaterThan(\".username\", \"text\", 1);Nightwatch API:sFor Nightwatch API:s please go here",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-native-android-javascript-training-guide": {
        "title": "Training Guide",
        "content": "40 minSetupCovered topicsPrerequisitesSetup Android app test on local machineSetup Android app test on SauceLabsStart50 minTests FrameworkCovered topicsExecution commandsUnderstand tests framework structureStart50 minAndroid AutomationCovered topicsDesired CapabilitiesNative Android locatorsStart",
        "url": "/Functional Testing/Native Android/JAVASCRIPT/Training Guide"
      },
    
      "documentation-functional-testing-native-android-javascript-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional JS Test Development Kit (TDK) is a set of tools for making native Android &amp; React Native apps end-to-end testing fast, user-friendly, and valuable at scale, across large teams, without those annoying false positives. Both emulators and real devices are supported.The following tools are part of the functional JS TDK:      Magellan - Magellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Nightwatch-Extra - Nightwatch is a friendly NodeJS-based wrapper for Selenium, allowing developers to author tests in a way that’s easy to learn and quick to iterate on. The Nightwatch-Extra adapter is the first of many adapters to come for bringing other webdriver wrappers into the TestArmada ecosystem.        Executor - Executor acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).        Reporter - Magellan can give you various test reports if configured with a proper reporter. There are already several reporters available in Testarmada to grab, however the simple API Testarmada exposes also allows to create a customized reporter in an easy way.        Admiral - Like a tree falling in the woods, a test report that nobody reads doesn’t make a sound. Admiral is a beautiful dashboard that makes it easy to check the latest cross-browser test results, and to spot trends and sources of failures.  Use CaseBuilt for Walmart ScaleBuilt at WalmartLabs to drive quality for the world’s largest retailer, TestArmada is battle-tested, enterprise-grade, and ready to take on end-to-end testing for your site.Results You Can TrustTestArmada won’t waste your team’s time or erode its trust with annoying false-positives. When failures occur, TestArmada intelligently retries the tests to smooth over common sources of “test flake”.More Signal, Less NoiseThe functional JS TDK tells you everything you need to know, and nothing you don’t. Notifications occur in real-time when tests fail, and a beautiful dashboard always shows the latest status for each suite.ImpactWith the functional JS TDK, WalmartLabs has made end-to-end testing part of the shared culture between dev &amp; QA. Both organizations collaborate to ensure quality at all levels development, staging, and production.Feature ListThe functional JS TDK supports:      Frameworks - Nightwatch &amp; Mocha        Reporters - xunit, json &amp; mongo db        Clouds - Saucelabs &amp; Testobject  CustomersThe following teams are using the functional iOS JS TDK:      Checkout RN        Store        Account Mobile        Omnichannel Mobile        Grocery Native Mobile  ",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Introduction"
      },
    
      "documentation-functional-testing-native-android-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre RequisiteThe functional JS TDK requires minimum node@4 and npm@3 for device testing.Getting started with the functional JS TDKTo proceed with native Android app test, you also need latest Xcode and it’s command line tools.SetupPlease follow the archetype project otto-archetype-app to have your first native app test automation project run in your local.Then please follow the boilerplate project boilerplate-nightwatch-mobile for more examples and advanced usage.Via Command Line ArgumentsMagellan which is part of the functional JS TDK is designed for running tests in massive scale, which means you’ve been granted the full control of the scalability. There are two ways to tell magellan how you want to scale your tests.All command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command in your favorite bash./node_modules/.bin/magellan --helpFollowing is an example telling magellan to run tests with 30 workers, 5 retry attempts per failed test and bail whole suite if any failure is met../node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5 --bail_fastConfigure test profileMagellan passes down test profile information, like which browser or test environment your test runs in, to its executor(s). Usually this is done by setting up a specific argument in magellan command, such as./node_modules/.bin/magellan --local_browser chromeVia –profile command line argumentMagellan can retrieve test profile information from an URL. This gives you the convenience of managing your test environments and sharing your configuration management in a more standard way. Furthermore, by putting test profiles in to a file, you can add more information into your test profile, such as screen resolution, orientation or device information for you app test.The hosted test profile file needs to follow the format of{  \"profiles\": {    \"microsoftedge\": [{      \"browser\": \"microsoftedge_14_Windows_10_Desktop\",      \"resolution\": \"1280x1024\",      \"executor\": \"sauce\"    }],}Magellan can read and resolve the hosted profile by following command../node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via./node_modules/.bin/magellan --profile http://some.host#microsoftedge,googlechrome59,firefox57Or, as a better way to handle multiple test profiles as a batch, you can put multiple test profiles into one collection, such as{  \"profiles\": {    \"tier-one-browsers\": [{        \"browser\": \"microsoftedge_14_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"chrome_latest_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"iphone_10_0_iOS_iPhone_7_Simulator\",        \"orientation\": \"portrait\",        \"appium\": {          \"app\": \"sauce-storage:my_app.zip\",          \"appiumVersion\": \"1.6.4\",          \"automationName\": \"xcuitest\",          \"sendKeyStrategy\": \"setValue\",          \"waitForAppScript\": \"true\"        }      }    ]  }}Then simply call magellan with./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json supports the same test profile format as the hosted test profile file. Put the above js code snippet in magellan.json and it is ready to use via./node_modules/.bin/magellan --profile tier-one-browsersEnable executorYou need to tell magellan which executor it should use for a test profile. By default, if no executor is specified in profile, magellan is going to run it with magellan-saucelabs-executor if it is configured in magellan.json or magellan will error out.At least one executor has to be enabled in magellan.json. Please follow these steps to enable executor:  Install necessary executor via npm install    npm install testarmada-magellan-saucelabs-executor --save        Add following code in your magellan.json      \"executors\": [ \"magellan-saucelabs-executor\",  ],      Run test with executor(s)Magellan allows to run tests with one or more executors at the same time. Typically this is done by passing a specific command line argument to magellan. For example, to enable magellan-local-executor for all the tests, this command line argument is required# to run in Chrome--local_browser chrome or# to run in both Chrome and Firefox--local_browsers chrome, firefox Here is another example to enable both magellan-local-executor and magellan-saucelabs-executor for your test:# to run in local Chrome and Safari 10 on Saucelabs--local_browser chrome --sauce_browser safari_10_OS_X_10_11_Desktop Using ReporterReporter extends magellan’s reporting mechanism and increases the report format that magellan supports. With reporters magellan can now create test report in various formats for different audiences.Enable reporter(s)To enable multiple reporters, simply add them in magellan.json  \"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ]Please note: By default, magellan prints logs to terminal console while running. This default behavior won’t change and cannot be changed no matter how many other reporters are enabled.Create tests with Nightwatch-extraNightwatch-extra supports everything that nightwatchjs supports. Please refer to nightwatchjs’ developer guide for the basic usage of nightwatchjs.Extend the base-test-class.jsNightwatch-extra’s base-test-class.js passes certain information, such as selenium session information and test result, back to magellan. We highly recommend all your tests extend it.const Test = require(\"testarmada-nightwatch-extra/lib/base-test-class\");module.exports = new Test({  \"Load goole page\": function (client) {    client.url(\"http://www.google.com\");  }});Enable nightwatch-extra commandTo use nightwatch-extra’s command API, you need to add its path to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\"  ],A typical flow of how nightwatch-extra’s command works is  Get all information, like selector, values, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element via do().All commands of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Enable nightwatch-extra assertionTo use nightwatch-extra’s assertion API, you need to add its path to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\"  ],A typical flow of how nightwatch-extra’s assertion works is  Get all information, like selector, expectedValue, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element and assert via assert().All assertions of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Page ObjectNightwatch-extra is fully compatible with nightwatchjs’ page object pattern. You can access nightwatch-extra’s API or your customized API in page object command via  createNewCreditCard: function() {    const selectors = this.elements;    return this      .clickEl(selectors.addCreditCardButton.selector)      .setElValue(selectors.firstName.selector, \"testarmada\");  },All nightwatchjs’ APIs are accessible and chainable with nightwatch-extra’s API or your customized API via  selectPayByCash: function() {    this      .clickMobileEl(\"accessibility id\", selectors.morePaymentOptions.selector)      .swipeMobileElTo(\"xpath\", selectors.visaCheckout.selector, 0, -50)      .api.pause(3000)      .clickMobileEl(\"xpath\", selectors.payWithCash.selector);    return this;  }",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Getting Started"
      },
    
      "documentation-functional-testing-native-android-javascript-faq": {
        "title": "FAQ",
        "content": "I’m having npm install failure, what should I do?Please make sure that you’re using compatible node and npm. Check versions by node -v and npm -vTo install Node and NPM, click here. NPM is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer.Which magellan command should I use to launch my test?Please read magellan help by ./node_modules/.bin/magellan –help first. If you cannot find what you want there, or if you’re still not sure, please reach us in slack channel lised belowHow should I run my test in different devices?If you want to test locally, please make sure corresponding dev tools are installed correctly. Also for android please make sure a proper AVD is set.How should I debug my test?Please use appium desktop app to get your element or coordinates.Can I have this feature?If you are asking for a customized command, please check if similar command exists in testarmada.io#API and nightwatch first. Or, if you are asking for a feature like data tools, or any other stuff that you think is useful, please ping us in slack channel.What to do if I cannot download and install some certain node packagesIf it’s Walmart internal npm packages are the problem ones, please follow the steps listed here.Bentonville: if you cannot reach a certain public npm packages because of the proxy issue. You can either use the sample project setup on looper to get your tests run on CI, or ask people to share their node packages via Box.Cannot check in your changesPlease make sure you have write access for the repo, and you need to set the SSH key right. To check for exiting SSH Keys, click here.  Generate a new SSH key and adding it to the ssh-agent, click here.  Add a new SSH key to your GitHub account, click here.",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/FAQ"
      },
    
      "documentation-functional-testing-native-android-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.      Magellan code base        Nightwatch-Extra code base  Bugs reportingPlease file the issue in the github projects above. Please ensure your issue has not been reported earlier.VersioningThe functional TDK follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.Customize commandWe provide a base-command.js for inheritance to implement your own command for browser test. To implement a command for browser usage, you need to  Inherit your command from the base-command.js.  Implement method do() and command()            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              command(…, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with an optional callback which will be called when the command successfully finishes.        Add the path of your new command to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\",    \"./node_modules/testarmada-nightwatch-extra/lib/commands/mobile\",    \"./lib/custom_commands\"  ],Customize assertionWe provide a base-assertion.js for inheritance to implement your own assertion for browser test. To implement an assertion for browser test, you need to  Inherit your assertion from the base-assertion.js.  Implement method do(), assert() and command().            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              assert(actual, expected)      Called by base assertion if element exists and is visible, you can do you own assertion in this method.      actual is the actual value returned by injectedJsCommand() method, expected is the expected value passed in command() method              command(selector, expected, …, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with a selector, an expected value and an optional callback which will be called when the assertion successfully finishes.        Add the path to your new assertion to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\",    \"./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile\",    \"./lib/custom_assertions\"  ],Contribute to reporterCreate a reporterA reporter must implement following methods.            Method      Purpose                  initialize()      initialize current reporter instance              listenTo(testRun, test, source)      listen to magellan’s test run              _handleMessage(testRun, test, msg)      will be called when magellan emits certain events              flush()      will be called when magellan finishes      Please note: _handleMessage() will be called per test. Please handle the error properly if it happens in one of the _handleMessage() so all your following _handleMessage() and flush() don’t error out.Enable your reporterTo enable multiple reporters, simply add them in magellan.json\"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ],",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-functional-testing-native-android-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Nightwatch Mobile boilerplateTo learn more about the functional JS TDK and to see an example project of how it can be used please go here",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-functional-testing-native-android-javascript-api-guide": {
        "title": "API Guide",
        "content": "Nightwatch-Extra API:sCommands.getEl()description:Returns a html elementSyntax:.getEl(selector, callback/*optional*/);Parameters:selector : css selector to identify the html element.callback : callback which includes the element information.Usage:.getEl(\".dropdown-link .user-name\", function(element){  console.log(element); // will print out {'ELEMENT': 1}});.getEls()description:Returns html elementsSyntax:.getEls(selector, callback/*optional*/);Parameters:selector : css selector to identify the html elements.callback : callback which includes the elements information.Usage:.getEls(\".dropdown-link .user-name\", function(element){  console.log(element);  // will print out [{'ELEMENT': 1}, .....]});.clickEl()description:Click a html elementSyntax:.clickEl(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : optional callback to be called when the command finishes.Usage:.clickEl(\"#submit\");.clickAutomationEl()description:Click an html element which has html attribute [data-automation-id].Syntax:.clickAutomationEl(id, callback/*optional*/);Parameters:id : value of data-automation-id attribute.callback : optional callback to be called when the command finishes.Usage:.clickAutomationEl(\"placeOrder\"); // equals to .clickEl('[data-automation-id=\"placeOrder\"]');.getElValue()description:Returns the textual value of a html element.Syntax:.getElValue(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : callback which includes the value of the element.Usage:.getElValue(\".user-profile\", function(profile){ });.setElValue()description:Sets value to a html element.Syntax:.setElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setElValue(\"#username\", \"fake@login.com\");.setMaskedElValue()description:Sets value to a masked html element like credit card number or phone number.Syntax:.setMaskedElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setMaskedElValue(\".phone-number\", \"123456789\");.moveToEl()description:Moves cursor to a html elementSyntax:.moveToEl(selector, xoffset, yoffset, callback/*optional*/);Parameters:selector : css selector to the html element.xoffset : x offset to move to, relative to the top-left corner of the element.yoffset : y offset to move to, relative to the top-left corner of the element.callback : optional callback to be called when the command finishes.Usage:.moveToEl(\".checkout\", 10, 10);.takeElScreenshot()description:Takes screenshot for a html element and save it to fileSyntax:.takeElScreenshot(selector, filename, callback/*optional*/);Parameters:selector : css selector to the html element.filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeElScreenshot(\".phone-number\", \"phone-number\");.takeScreenhot()description:Takes screenshot for the page.Syntax:.takeScreenhot(filename, callback/*optional*/);Parameters:filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeScreenhot(\"home-page\");.assert.elContainsText()description:Asserts if current element contains a given textSyntax:.assert.elContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elContainsText(\".username\", \"testarmada\");.assert.elNotContainsText()description:Asserts if current element doesn’t contain a given textSyntax:.assert.elNotContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elNotContainsText(\".username\", \"testarmada\");.assert.selectorHasLength()description:Asserts if current selector returns given amount of elementsSyntax:.assert.selectorHasLength(selector, value);Parameters:selector : css selector to the html element.value : numeric value to assert.Usage:.assert.selectorHasLength(\".username\", 1);.assert.elValueContains()description:Asserts if current element contains the given valueSyntax:.assert.elValueContains(selector, value);Parameters:selector : css selector to the html element.value : textual value to assert.Usage:.assert.elValueContains(\".username\", \"Leo\");.assert.elLengthGreaterThan()description:Asserts if the length of an element’s attribute is greater than a numberSyntax:.assert.elLengthGreaterThan(selector, using, value);Parameters:selector : css selector to the html element.using : element attribute, can be chosen from [“value”, “text”, “html”, “length”].value : numeric value to assert.Usage:.assert.elLengthGreaterThan(\".username\", \"text\", 1);Nightwatch API:sFor Nightwatch API:s please go here",
        "url": "/documentation/Functional Testing/Native Android/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-native-android-java-training-guide": {
        "title": "Training Guide",
        "content": "120 minTraining 101Covered topicsLearn how to setup TDK in localLearn run tests by TDKLearn advanced config of the TDKStart120 minTraining 201Covered topicsLearn how to setup looper job with TDKLearn .looper.yml about the TDKLearn analyze the TDK logStart",
        "url": "/Functional Testing/Native Android/JAVA/Training Guide"
      },
    
      "documentation-functional-testing-native-android-java-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional native Android Test Development Kit (TDK) enables you to execute your native Android tests easily, reliably and quickly in the cloud. By using Flank which is part of the TDK, users can run their native Android tests in parallell on Firebase test lab in just a few steps.  The TDK will also provide a summarized diagram and logs for each test package and detailed XML test reports are shown in the job directly and also sent to our DI platform to track the results using the Test Armada dashboard.Use CaseFlank which is part of the TDK is a Firebase Test Lab tool for massively-scaling your automated Android tests. Run large test suites across many devices/versions/configurations at the same time, in parallel. Flank can easily be used in a CI environment where Gradle (or similar) first builds the APK:s and then Flank is used to execute the tests. By using our Flank API:s in Looper, users can easily get access to Flank and with a few simple API:s setup tests to be run on Firebase Test Lab.ArchitectureFeature ListThe functional native Android TDK has the following features:      Sharding - By executing tests in shards Flank blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Android native tests - Flank supports execution of native android tests on Firebase Test Lab.        Execution options - You can specify in which class/package/annotation/testFile you would like tests to run.        Fetches XML results - After the test is done Flank fetches all test result XML files and stores them in a folder results.        Continous Integration - Flank is integrated into Looper and can be easily setup using its API:s.  CustomersThe following teams are using the functional native Android TDK:      Pickup        MoneyServices  ",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Introduction"
      },
    
      "documentation-functional-testing-native-android-java-getting-started": {
        "title": "Getting Started",
        "content": "PrerequisiteBefore configuring Flank and starting your Android test jobs, ensure Python (&gt;= 2.7.x) is installed on your local or CI slave, learn more here.Configuration filesconfig.properties (optional but recommended)The config.properties file is used when you need to customize the Flank tests, all options can be seen here.service-account.json (optional but recommended)The file to provide GCloud/Firebase auth information, learn more. Sample:{  \"type\": \"service_account\",  \"project_id\": \"Your Firebase project id\",  \"private_key_id\": \"Your private key id\",  \"private_key\": \"Your private key\",  \"client_email\": \"The client email in Firebase\",  \"client_id\": \"The client id in Firebase\",  \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",  \"token_uri\": \"https://accounts.google.com/o/oauth2/token\",  \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",  \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/walmart-fb668%40appspot.gserviceaccount.com\"}If not set, the Flank test will default point to default Walmart Firebase project walmart-fb668..looper.yml (required in looper)If you need run your test in a CI environment like looper, a looper config file is needed, learn more here.Environment variablesAll environment variables can be found in the Developer GuideLooper integration:In looper you can inherit from the Flank base looper job in your .yml file: inherit: 'job://otto-Android_native' it will include all default environment variables, can override them in your .yml anytime, or customize environment variables yourself from the beginning..looper.yml sampleinherit: 'job://otto-Android_native'envs:  global:    variables:      APK_PATH: ./ExampleTestProject_AndroidStudio/app/build/outputs/apk/app-debug.apk      TEST_APK_PATH: ./ExampleTestProject_AndroidStudio/app/build/outputs/apk/app-debug-androidTest.apk      PACKAGE: ''      #FAIL_JOB_ON_TEST_FAIL: falseflows:  default:    - ./apk_build.sh    - shell (name run_tests): |           curl --header \"Authorization: token ${GH_API_TOKEN}\" \\           --header \"Accept: application/vnd.github.v3.raw\" \\           --location https://gecgithub01.walmart.com/api/v3/repos/otto/scripts/contents/looper/flank/flank.sh?ref=${BUILD_URL_REF} | bashTests resultsThe results are published to slack.Script will exit with error code 1 if there are any test failures, which means that it will fail the looper build.Manual setupManual setup is as easy as automation, just follow steps:  Export all required environment variables  Recommended step: Create config.properties followed above instruction  Recommended step: Create service-account.json followed above instruction  Run scripts curl --header \"Authorization: token ${GH_API_TOKEN}\" --header \"Accept: application/vnd.github.v3.raw\" --location https://gecgithub01.walmart.com/api/v3/repos/otto/scripts/contents/looper/flank/flank.sh?ref=${BUILD_URL_REF} | bashManual setup sample#!/usr/bin/env bashexport GH_API_TOKEN=2a73a73566c54ee7152e1698374b9fd497c635dfexport APK_PATH=./build/outputs/apk/*-debug.apkexport TEST_APK_PATH=./build/outputs/apk/*-debug-androidTest.apkexport PACKAGE=''#export FAIL_JOB_ON_TEST_FAIL=falseexport BUILD_URL_REF='flank_beta'curl --header \"Authorization: token ${GH_API_TOKEN}\" \\--header \"Accept: application/vnd.github.v3.raw\" \\--location https://gecgithub01.walmart.com/api/v3/repos/otto/scripts/contents/looper/flank/flank.sh?ref=${BUILD_URL_REF} | bash",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Getting Started"
      },
    
      "documentation-functional-testing-native-android-java-faq": {
        "title": "FAQ",
        "content": "How can I use Flank to begin my Android tests?See Getting started and Developer Guide for help.Are there any example projects I can have a look at?Yes please see boilerplate-android-espresso-automation and follow the README, also please see this looper example job.Where can I download flank.jar?You can either download flank from here or use the following command:curl -o Flank.jar --proxy http://gec-proxy-svr.homeoffice.wal-mart.com:8080/ \\--location --fail https://dl.bintray.com/flank1/Flank/Flank-1.5.0.jarWhy does gradle timeout in looper?Please inherit the flank base looper job in your .looper.yml file inherit: 'job://otto-Android_native' or specify your own proxy via JAVA_OPTS variable, gradle.org is not whitelisted yet, some dependencies cannot be retrieved from gradle tool in looper.Where do I go to ask questions?Please join our Slack channel #otto_flank for more help.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/FAQ"
      },
    
      "documentation-functional-testing-native-android-java-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.  Flank code baseBranch OrganizationFor Flank, we will mainly maintain master branch as a stable branch.Data flowAs shown in “How Flank and scripts work” section, developers should follow such a structure to make a contribution.Bugs reportingPlease file the issue here, please ensure your issues are not reported before.VersioningFlank follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.How to contact us  Join #otto_flank",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Contribution Guide"
      },
    
      "documentation-functional-testing-native-android-java-boilerplates": {
        "title": "Boilerplates",
        "content": "Android Espresso boilerplateTo download a boilerplate project containing Espresso tests please go hereExample Looper jobTo see an example of how the native Android TDK can be setup on Looper please go here",
        "url": "/documentation/Functional Testing/Native Android/JAVA/Boilerplates"
      },
    
      "documentation-functional-testing-native-android-java-api-guide": {
        "title": "API Guide",
        "content": "Environment variables            Variable      Description      Required      Default Value                  GH_API_TOKEN      Token used to fetch files in github      Yes                     APK_PATH      Path of the main apk file      Yes                     TEST_APK_PATH      Path of the test apk file      Yes                     PACKAGE      Package name of test cases to execute, if not defined all tests are executed                            JAVA_OPTS      Path to set proxy for gradle connection      Yes in Looper and not inherit: 'job://otto-Android_native'                     FLANK_VERSION      Version of Flank             1.5.0              GCLOUD_VERSION      Version of google-cloud-sdk             176.0.0              OSTYPE      OS type, support linux-gnu and darwin             linux-gnu              SLACK_TOKEN      Bot token to use to publish the test results to slack. Default to token of android_test_bot.                            SLACK_CHANNEL      Slack channel to publish the test results. Defaults to #android_test.                            FAIL_JOB_ON_TEST_FAIL      when set to false, the looper job will not fail if no error in Flank scripts and even there’s failed test cases, this is used when need to show the Junit tests results in looper job main page for the first time.             true              BUILD_URL_REF      branch to specify version of Flank scripts             flank_beta (only one valid for now)              SERVICE_ACCOUNT_URL      the URL to download the service_account.json for tests.      recommended             conifg.propertiesThe config.properties file is used when you need to customize the Flank tests, all options can be seen at configure-flank.service-account.jsonAll options in service-account.json are in thi sample:{  \"type\": \"service_account\",  \"project_id\": \"Your Firebase project id\",  \"private_key_id\": \"Your private key id\",  \"private_key\": \"Your private key\",  \"client_email\": \"The client email in Firebase\",  \"client_id\": \"The client id in Firebase\",  \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",  \"token_uri\": \"https://accounts.google.com/o/oauth2/token\",  \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",  \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/walmart-fb668%40appspot.gserviceaccount.com\"}Learn more at GCould auth doc.",
        "url": "/documentation/Functional Testing/Native Android/JAVA/API Guide"
      },
    
      "documentation-data-insights-performance-trending-introduction": {
        "title": "Introduction",
        "content": "Trending Performance Data Insights allow the developer to see how the performanceof their application has evolved over time.Use caseAs applications change over time with new code updates and added features, the performanceof the application can be both positively and negatively affected. Easily accessed trendingperformance data enables the development team to identify which change introduced an increaseor decrease in the performance of their application, giving crucial information in theeffort to continue improvements to performance, or fix degradations.ImpactPerformance is one the most impacting factors on the customer experience, and can be verydifficult to diagnose when problems arise. By providing reliable, simple access to the datafrom performance testing, the developer benefits from increased knowledge of potentialissues without friction and the Walmart customer gets an enhanced experience.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Performance/Trending/Introduction"
      },
    
      "documentation-data-insights-performance-real-time-introduction": {
        "title": "Introduction",
        "content": "Real-Time Performance Data Insights allow the developer to see results of their performancetesting as they are returned, reducing the time spent waiting for this information.Use caseWhen running performance tests, the sooner the data is available, the faster the developercan take action to correct issues.After configuring and running performance tests, the developer would access the real-timeperformance reports to assess the results as they are reported.ImpactThe less time developers waste waiting for test data to be available, the more productivethose developers are - and the better their workflow is. What results is an improvedexperience for developers in the organization, and - through improved application qualitythat comes from these insights - a greatly improved experience for the Walmart customer.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Performance/Real Time/Introduction"
      },
    
      "documentation-data-insights-functional-trending-introduction": {
        "title": "Introduction",
        "content": "Trending Functional Data Insights allow the developer to see how the health of theirfunctional test suite has evolved over time.Use caseAs applications change over time with new code updates and added features, there is thepotential for functionality and appearance to break or unexpectedly change. Easily accessedtrending functional data enables the development team to assess the impact of these changeson the health of their test suite.This helps identify repeated issues being introduced, highlight features that are consistentlyfailing on certain browsers/devices and pinpoint browsers/devices that need special attentionby the development team.ImpactHaving access to this trending data allows teams to make lasting changes to their developmentworkflows to avoid repeating the same mistakes. This saves many hours of engineering time overthe life of a project, and improves code quality across the organization.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Functional/Trending/Introduction"
      },
    
      "documentation-data-insights-functional-real-time-introduction": {
        "title": "Introduction",
        "content": "Real-Time Functional Testing Data Insights allow the developer to see results of theirfunctional testing as they are returned, reducing the time spent waiting for this information.Use caseWhen running functional tests on multiple browsers or devices, the sooner the data is available,the faster the developer can take action to correct issues.After configuring and running functional tests, the developer would access the real-timefunctional reports to assess the results as they are reported.ImpactThe less time developers waste waiting for test data to be available, the more productivethose developers are - and the better their workflow is. What results is an improvedexperience for developers in the organization, and - through improved application qualityand visual appearance that comes from these insights - a greatly improved experiencefor the Walmart customer.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Functional/Real Time/Introduction"
      }
    
  };
</script>
<script src="/js/lunr.min.js"></script>
<script src="/js/search.js"></script>

	</div>

	<footer>
		<img class="left-footer-logo" alt="Left Footer Logo"
			 src="/documentation/images/dxt-logo.png"
			 srcset="/documentation/images/dxt-logo%402x.png 2x,
					 /documentation/images/dxt-logo%403x.png 3x">
		
		<span class="copyright">&copy; 2018 Walmart Inc.</span>
		
		<img class="right-footer-logo" alt="Right Footer Logo"
			 src="/documentation/images/walmartlabs-logo.png"
			 srcset="/documentation/images/walmartlabs-logo%402x.png 2x,
			 		 /documentation/images/walmartlabs-logo%403x.png 3x">
	</footer>

</body>
</html>
